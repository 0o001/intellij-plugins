package com.intellij.coldFusion

import com.intellij.codeInsight.completion.CompletionType
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.sql.completion.SqlCompletionTestCase
import com.intellij.sql.datasource.SqlDataSourceTestCase
import com.intellij.sql.dialects.SqlDialectMappings
import com.intellij.sql.dialects.SqlLanguageDialect
import com.intellij.sql.dialects.sqlite.SqliteDialect
import com.intellij.sql.psi.SqlLanguage
import com.intellij.util.FileContentUtil

/**
 * SQL injection completion tests for CFML without using data from datasource. Assuming that it is necessary to test only one of dialects, so let's take SQL92 for example.  Original tests and data are got from {@link com.intellij.sql.completion.AllSqlCompletionTest}
 *
 * @author Sergey Karashevich
 */
class CfmlSqlInjectionCompletionDatasourceTest : SqlCompletionTestCase(null) {

  val CFML_QUERY_TEMPLATE = "<cfquery><insert></cfquery>"

  override fun getTestDataPath(): String = CfmlTestUtil.BASE_TEST_DATA_PATH + basePath

  override fun getBasePath() = "/injection"

  override fun setUp() {
    //this object needed just for data source creation
    super.setUp()
    object : SqlDataSourceTestCase() {
      fun create() {
        this.myFixture = this@CfmlSqlInjectionCompletionDatasourceTest.myFixture
        createDataSource(SqliteDialect.INSTANCE, null, "Sqlite.create.ddl")
      }
    }.create()
  }

  fun testCompletion() {
    myDoTestVariants("select * from <caret>", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql01() {
    myDoTestVariants("select * from autogenerated_author where name=<cfqueryparam> and <caret>", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "author_id")
  }

  fun testCompletionWihSplittedSql02() {
    myDoTestVariants("select * from autogenerated_author where name=<cfqueryparam value=\"some value is here\"> and <caret>", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "author_id")
  }

  fun testCompletionWihSplittedSql03() {
    myDoTestVariants("select * from <caret> where name=<cfqueryparam> and author_id='some_id'", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql04() {
    myDoTestVariants("select * from <caret> where name=<cfqueryparam value=\"some value is here\"> and author_id='some_id'", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql05() {
    myDoTestVariants("select * from <caret> where name=<cfqueryparam value=\"some value is here\"> and author_id='some_id'", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql06() {
    myDoTestVariants("select * from <caret> WHERE name=<cfqueryparam> ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql07() {
    myDoTestVariants("select * <caret> autogenerated_author WHERE name=<cfqueryparam> ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "FROM")
  }

  fun testCompletionWihSplittedSql08() {
    myDoTestVariants("select * from autogenerated_author where name=<cfif>'one variant'<cfelse>'second variant'</cfif> AND <caret> ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "author_id")
  }

  fun testCompletionWihSplittedSql09() {
    myDoTestVariants("select * from <caret> where name=<cfif>'one variant'<cfelse>'second variant'</cfif> AND author_id='frefe' ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql10() {
    myDoTestVariants("select * <caret> autogenerated_author where name=<cfif>'one variant'<cfelse>'second variant'</cfif> AND author_id='frefe' ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "FROM")
  }

  fun testCompletionWihSplittedSql11() {
    myDoTestVariants("select * from <caret> where name=<cfif>'one variant'</cfif> AND author_id='frefe' ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "autogenerated_author")
  }

  fun testCompletionWihSplittedSql12() {
    myDoTestVariants("select * from autogenerated_author where name=<cfif>'one variant'</cfif> AND <caret> ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "author_id")
  }

  fun testCompletionWihSplittedSql13() {
    myDoTestVariants("select * <caret> autogenerated_author where name=<cfif>'one variant'<cfelse>'second variant'</cfif> ", CompletionType.BASIC, 1, SqlCompletionTestCase.MatchType.CONTAINS, "FROM")
  }

  private fun myDoTestVariants(sql: String,
                               type: CompletionType,
                               count: Int,
                               matchType: SqlCompletionTestCase.MatchType,
                               vararg variants: String) {
    val dialect = SqlLanguage.INSTANCE.dialects.find { it.id == "SQL92" }
    SqlDialectMappings.getInstance(project).setMapping(null, dialect as SqlLanguageDialect)
    val file = myFixture.file
    println(javaClass.simpleName + "." + getTestName(true) + ": " + dialect.getID())
    configureByTemplate(CFML_QUERY_TEMPLATE, sql)
    if (file != null) FileContentUtil.reparseFiles(project, listOf<VirtualFile>(file.virtualFile), false)
    doTestVariantsInner(type, count, matchType, *variants)
  }

  private fun configureByTemplate(cfmlTemplate: String, sqlInjection: String) {
    val CFML_FILE_TEXT = cfmlTemplate.replace("<insert>", sqlInjection)
    myFixture.configureByText("a.cfml", CFML_FILE_TEXT)
  }

}
