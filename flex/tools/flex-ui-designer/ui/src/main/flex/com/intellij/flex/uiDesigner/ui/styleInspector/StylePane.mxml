<Panel xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns="cocoa" implements="org.flyti.plexus.Injectable, com.intellij.flex.uiDesigner.ui.styleInspector.StylePaneContext">
  <fx:Script><![CDATA[
    import cocoa.ScrollPolicy;

    import com.intellij.flex.uiDesigner.Document;
    import com.intellij.flex.uiDesigner.css.CssDeclaration;
    import com.intellij.flex.uiDesigner.css.CssRuleset;
    import com.intellij.flex.uiDesigner.css.MergedCssStyleDeclarationEx;
    import com.intellij.flex.uiDesigner.css.NonSharedStyleDeclarationProxy;
    import com.intellij.flex.uiDesigner.css.StyleManagerEx;
    import com.intellij.flex.uiDesigner.util.ImmutableFakeObjectProxy;

    import org.flyti.util.ArrayList;

    private const source:Vector.<Object> = new Vector.<Object>(1);
    private var sourceItemCounter:int = 0;
    private const sourceList:ArrayList = new ArrayList(source);

    private const namespaceUnificator:NamespaceUnificator = new NamespaceUnificator();

    private static const cssDeclarationItemRendererFactory:ClassFactory = new ClassFactory(TextBlockRenderer);
    cssDeclarationItemRendererFactory.properties = {blockFactory: CssRulesetTextBlockFactory};

    private static const namespaceListRendererFactory:ClassFactory = new ClassFactory(TextBlockRenderer);
    namespaceListRendererFactory.properties = {blockFactory: NamespaceListTextBlockFactory};

    private static const groupItemRendererFactory:ClassFactory = new ClassFactory(GroupItemRenderer);

    private var _rulesetPrinter:CssRulesetPrinter;
    public function get rulesetPrinter():CssRulesetPrinter {
      return _rulesetPrinter;
    }

    //noinspection JSUnusedGlobalSymbols
    public function set rulesetPrinter(value:CssRulesetPrinter):void {
      _rulesetPrinter = value;
    }

    private var _document:Document;
    public function set document(value:Document):void {
      _document = value;
      if (_document == null) {
        _rulesetPrinter.module = null;
        _rulesetPrinter.interactor.module = null;
      }
      else {
        _rulesetPrinter.module = _document.module;
        _rulesetPrinter.interactor.module = _document.module;
      }
    }

    public function set element(value:DisplayObject):void {
      //_rulesetPrinter.availableWidth = PanelSkin(skin).contentWidth;
      _rulesetPrinter.availableWidth = Object(skin).contentWidth;
      _rulesetPrinter.namespaceUnificator = namespaceUnificator;
      updateData(value);
    }

    private var _styleManager:StyleManagerEx;
    public function get styleManager():StyleManagerEx {
      return _styleManager;
    }

    override protected function skinAttachedHandler():void {
      super.skinAttachedHandler();

      list.laf = laf;
    }

    private function updateData(element:Object):void {
      sourceItemCounter = 1;
      if (element == null) {
        _styleManager = null;
        return;
      }

      namespaceUnificator.reset();
      _styleManager = element.styleManager;

      var collected:Dictionary = new Dictionary();
      collect(element.inheritingStyles, collected, false);

      source[0] = namespaceUnificator;
      source.length = sourceItemCounter;

      if (list.dataProvider == null) {
        list.dataProvider = sourceList;
      }
      else {
        sourceList.refresh();
      }
    }

    private function collect(styleDeclarationProxy:ImmutableFakeObjectProxy, collected:Dictionary,
                             onlyRulesetWithInheritedStyles:Boolean):void {
      var allocatedGroupItemIndex:int;
      if (onlyRulesetWithInheritedStyles) {
        allocatedGroupItemIndex = sourceItemCounter++;
        if (sourceItemCounter > source.length) {
          source.length = sourceItemCounter + 2;
        }
      }

      var declarations:Object = styleDeclarationProxy.declarations;
      for (var i:int = declarations.length - 1; i > -1; i--) {
        var declaration:Object = declarations[i];
        if (!(declaration in collected)) {
          collected[declaration] = true;
          if (declaration is MergedCssStyleDeclarationEx) {
            for each (var ruleset:CssRuleset in MergedCssStyleDeclarationEx(declaration).rulesets) {
              if (!onlyRulesetWithInheritedStyles || containsInheritStyle(ruleset)) {
                namespaceUnificator.process(ruleset);
                source[sourceItemCounter++] = ruleset;
              }
            }
          }
          else if (!onlyRulesetWithInheritedStyles || containsInheritStyle(declaration.ruleset)) {
            source[sourceItemCounter++] = declaration.ruleset;
          }
        }
      }

      if (onlyRulesetWithInheritedStyles) {
        if (allocatedGroupItemIndex == (sourceItemCounter - 1)) {
          sourceItemCounter--;
        }
        else {
          source[allocatedGroupItemIndex] = createGroupItem(DisplayObjectContainer(styleDeclarationProxy is NonSharedStyleDeclarationProxy
                                                                                     ? NonSharedStyleDeclarationProxy(styleDeclarationProxy)
            .owner : null));
        }
      }

      if (styleDeclarationProxy is NonSharedStyleDeclarationProxy) {
        collect(NonSharedStyleDeclarationProxy(styleDeclarationProxy).parent, collected, true);
      }
    }

    private function containsInheritStyle(ruleset:CssRuleset):Boolean {
      var declarations:Vector.<CssDeclaration> = ruleset.declarations;
      for (var i:int, n:int = declarations.length; i < n; i++) {
        if (styleManager.isInheritingStyle(declarations[i].name)) {
          return true;
        }
      }

      return false;
    }

    private var groupItemCache:Dictionary = new Dictionary(true);

    private function createGroupItem(owner:DisplayObjectContainer):StyleDeclarationGroupItem {
      var item:StyleDeclarationGroupItem = groupItemCache[owner];
      if (item == null) {
        item = new StyleDeclarationGroupItem(owner);
        groupItemCache[owner] = item;
      }
      return item;
    }

    private function itemRendererFunction(item:Object):IFactory {
      return item is StyleDeclarationGroupItem ? groupItemRendererFactory : (item is NamespaceUnificator ? namespaceListRendererFactory
        : cssDeclarationItemRendererFactory);
    }

    public function get rulesets():Vector.<Object> {
      return source;
    }
    ]]></fx:Script>

  <ScrollView horizontalScrollPolicy="{ScrollPolicy.OFF}">
    <DataGroup id="list" itemRendererFunction="itemRendererFunction"/>
  </ScrollView>
</Panel>