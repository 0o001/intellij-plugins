<inspectors:AbstractInspector xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns="cocoa" xmlns:inspectors="com.intellij.flex.uiDesigner.ui.inspectors.*"
                              implements="com.intellij.flex.uiDesigner.ui.inspectors.styleInspector.StylePaneContext">
  <fx:Script><![CDATA[
    import cocoa.ScrollPolicy;

    import com.intellij.flex.uiDesigner.Document;
    import com.intellij.flex.uiDesigner.Module;
    import com.intellij.flex.uiDesigner.css.CssDeclaration;
    import com.intellij.flex.uiDesigner.css.CssRuleset;
    import com.intellij.flex.uiDesigner.css.MergedCssStyleDeclarationEx;
    import com.intellij.flex.uiDesigner.css.NonSharedStyleDeclarationProxy;
    import com.intellij.flex.uiDesigner.css.StyleManagerEx;
    import com.intellij.flex.uiDesigner.util.ImmutableFakeObjectProxy;

    import org.flyti.util.ArrayList;

    private const source:Vector.<Object> = new Vector.<Object>(1);
    private var sourceItemCounter:int;
    private const sourceList:ArrayList = new ArrayList(source);

    private const namespaceUnificator:NamespaceUnificator = new NamespaceUnificator();

    private static const cssDeclarationItemRendererFactory:ClassFactory = new ClassFactory(TextBlockRenderer);
    cssDeclarationItemRendererFactory.properties = {blockFactory: CssRulesetTextBlockFactory};

    private static const namespaceListRendererFactory:ClassFactory = new ClassFactory(TextBlockRenderer);
    namespaceListRendererFactory.properties = {blockFactory: NamespaceListTextBlockFactory};

    private static const groupItemRendererFactory:ClassFactory = new ClassFactory(GroupItemRenderer);

    private var _rulesetPrinter:CssRulesetPrinter;
    public function get rulesetPrinter():CssRulesetPrinter {
      return _rulesetPrinter;
    }

    //noinspection JSUnusedGlobalSymbols
    public function set rulesetPrinter(value:CssRulesetPrinter):void {
      _rulesetPrinter = value;
    }

    private var module:Module;

    public function set document(value:Document):void {
      if (value == null) {
        module = null;
        _styleManager = null;
      }
      else {
        module = value.module;
        _styleManager = value.styleManager;
      }

      _rulesetPrinter.module = module;
      _rulesetPrinter.interactor.module = module;
    }

    public function set element(value:Object):void {
      _rulesetPrinter.availableWidth = Object(skin).contentWidth;
      _rulesetPrinter.namespaceUnificator = namespaceUnificator;
      updateData(value);
    }

    private var _styleManager:StyleManagerEx;
    public function get styleManager():StyleManagerEx {
      return _styleManager;
    }

    private function updateData(element:Object):void {
      if (element == null) {
        clear();
        emptyText = "No Selection";
        return;
      }
      else if (!("inheritingStyles" in element)) {
        clear();
        emptyText = "Not Applicable";
        return;
      }
      else {
        emptyText = null;
      }

      sourceItemCounter = 1;
      source[0] = namespaceUnificator;

      namespaceUnificator.reset();

      var collected:Dictionary = new Dictionary();
      collect(element.inheritingStyles, collected, false);

      source.length = sourceItemCounter;

      if (list.dataProvider == null) {
        list.dataProvider = sourceList;
      }
      else {
        sourceList.refresh();
      }
    }

    private function collect(styleDeclarationProxy:ImmutableFakeObjectProxy, collected:Dictionary,
                             onlyRulesetWithInheritedStyles:Boolean):void {
      var allocatedGroupItemIndex:int;
      if (onlyRulesetWithInheritedStyles) {
        allocatedGroupItemIndex = sourceItemCounter++;
        if (sourceItemCounter > source.length) {
          source.length = sourceItemCounter + 2;
        }
      }

      var declarations:Object = styleDeclarationProxy.declarations;
      for (var i:int = declarations.length - 1; i > -1; i--) {
        var declaration:Object = declarations[i];
        if (!(declaration in collected)) {
          collected[declaration] = true;
          if (declaration is MergedCssStyleDeclarationEx) {
            for each (var ruleset:CssRuleset in MergedCssStyleDeclarationEx(declaration).rulesets) {
              if (!onlyRulesetWithInheritedStyles || containsInheritStyle(ruleset)) {
                namespaceUnificator.process(ruleset);
                source[sourceItemCounter++] = ruleset;
              }
            }
          }
          else if (!onlyRulesetWithInheritedStyles || containsInheritStyle(declaration.ruleset)) {
            source[sourceItemCounter++] = declaration.ruleset;
          }
        }
      }

      if (onlyRulesetWithInheritedStyles) {
        if (allocatedGroupItemIndex == (sourceItemCounter - 1)) {
          sourceItemCounter--;
        }
        else {
          var sd:NonSharedStyleDeclarationProxy = styleDeclarationProxy as NonSharedStyleDeclarationProxy;
          // if we have multi global (IDEA-72159), we must show it in one group (only one "Global" group item)
          if (sd != null) {
            source[allocatedGroupItemIndex] = createGroupItem(DisplayObjectContainer(sd.owner));
          }
          else {
            var globalItem:StyleDeclarationGroupItem = createGroupItem(null);
            if (source.indexOf(globalItem) == -1) {
              source[allocatedGroupItemIndex] = globalItem;
            }
            else {
              source[allocatedGroupItemIndex] = source[allocatedGroupItemIndex + 1];
              sourceItemCounter--;
            }
          }
        }
      }

      if (styleDeclarationProxy is NonSharedStyleDeclarationProxy) {
        collect(NonSharedStyleDeclarationProxy(styleDeclarationProxy).parent, collected, true);
      }
    }

    private function containsInheritStyle(ruleset:CssRuleset):Boolean {
      var declarations:Vector.<CssDeclaration> = ruleset.declarations;
      for (var i:int, n:int = declarations.length; i < n; i++) {
        if (styleManager.isInheritingStyle(declarations[i].name)) {
          return true;
        }
      }

      return false;
    }

    private var groupItemCache:Dictionary = new Dictionary(true);

    private function createGroupItem(owner:DisplayObjectContainer):StyleDeclarationGroupItem {
      var item:StyleDeclarationGroupItem = groupItemCache[owner];
      if (item == null) {
        item = new StyleDeclarationGroupItem(owner);
        groupItemCache[owner] = item;
      }
      return item;
    }

    private static function itemRendererFunction(item:Object):IFactory {
      return item is StyleDeclarationGroupItem ? groupItemRendererFactory : (item is NamespaceUnificator ? namespaceListRendererFactory
        : cssDeclarationItemRendererFactory);
    }

    public function get rulesets():Vector.<Object> {
      return source;
    }


    override protected function skinAttached():void {
      super.skinAttached();

      BorderedDataGroup(list).border = laf.getBorder("StyleInspector.DataGroup.b");
    }

    private function clear():void {
      _styleManager = null;
      if (list.dataProvider != null) {
        source.length = 0;
        sourceList.refresh();
      }
    }
    ]]></fx:Script>

  <ScrollView horizontalScrollPolicy="{ScrollPolicy.OFF}">
    <BorderedDataGroup id="list" itemRendererFunction="itemRendererFunction"/>
  </ScrollView>
</inspectors:AbstractInspector>