package com.intellij.lang.javascript.flex.build;

import com.intellij.ProjectTopics;
import com.intellij.compiler.CompilerConfiguration;
import com.intellij.facet.FacetManager;
import com.intellij.lang.javascript.ActionScriptFileType;
import com.intellij.lang.javascript.JavaScriptSupportLoader;
import com.intellij.lang.javascript.flex.*;
import com.intellij.lang.javascript.flex.flexunit.FlexUnitPrecompileTask;
import com.intellij.lang.javascript.flex.run.RunMainClassPrecompileTask;
import com.intellij.lang.javascript.flex.sdk.AirMobileSdkType;
import com.intellij.lang.javascript.flex.sdk.AirSdkType;
import com.intellij.lang.javascript.flex.sdk.FlexSdkUtils;
import com.intellij.lang.javascript.flex.sdk.FlexmojosSdkType;
import com.intellij.lang.javascript.psi.ecmal4.JSPackageStatement;
import com.intellij.lang.javascript.psi.ecmal4.JSQualifiedNamedElement;
import com.intellij.lang.javascript.psi.stubs.JSQualifiedElementIndex;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.CompileContext;
import com.intellij.openapi.compiler.CompilerManager;
import com.intellij.openapi.compiler.CompilerMessageCategory;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.fileTypes.StdFileTypes;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.projectRoots.Sdk;
import com.intellij.openapi.roots.*;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.openapi.vfs.*;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.stubs.StubIndex;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.util.Alarm;
import com.intellij.util.SystemProperties;
import com.intellij.util.containers.BidirectionalMap;
import com.intellij.util.messages.MessageBusConnection;
import com.intellij.util.text.StringTokenizer;
import com.intellij.xml.util.XmlUtil;
import gnu.trove.THashMap;
import gnu.trove.TObjectIntHashMap;
import gnu.trove.TObjectIntProcedure;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author Maxim.Mossienko
 *         Date: Jul 26, 2008
 *         Time: 3:55:46 PM
 */
public class FlexCompilerHandler extends AbstractProjectComponent {

  private static final Logger LOG = Logger.getInstance(FlexCompilerHandler.class.getName());
  private static final boolean KEEP_TEMP_FILES = Boolean.parseBoolean(System.getProperty("idea.keep.flex.temporary.files"));

  private final ModuleToRelatedFilesCache myModuleToRelatedFilesCache;
  private BuiltInFlexCompilerHandler myBuiltInFlexCompilerHandler;
  private final TObjectIntHashMap<String> commandToIdMap = new TObjectIntHashMap<String>();
  private final Map<FlexBuildConfiguration.Type, ModuleOrFacetCompileCache> myCompileCache = new EnumMap<FlexBuildConfiguration.Type, ModuleOrFacetCompileCache>(FlexBuildConfiguration.Type.class);
  @NonNls private static final String FCSH_ASSIGNED_MARKER = "fcsh: Assigned ";
  private boolean mySavingConfigOurselves;
  private boolean myRequestedQuit;

  static final String LOCALE_TOKEN = "{locale}";
  public static Key<FlexBuildConfiguration> OVERRIDE_BUILD_CONFIG = Key.create("OVERRIDE_FLEX_BUILD_CONFIG");


  private static class ModuleOrFacetCompileCache {
    public final THashMap<Object, String> moduleOrFacetToCommand = new THashMap<Object, String>();
    public final BidirectionalMap<Object, VirtualFile> moduleOrFacetToAutoGeneratedConfig = new BidirectionalMap<Object, VirtualFile>();
    public final THashMap<VirtualFile, Long> configFileToTimestamp = new THashMap<VirtualFile, Long>();
  }

  public FlexCompilerHandler(Project project) {
    super(project);

    MessageBusConnection connection = project.getMessageBus().connect(project);

    connection.subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {
      public void beforeRootsChange(ModuleRootEvent event) {
      }

      public void rootsChanged(ModuleRootEvent event) {
        quitCompilerShell();
      }
    });

    myModuleToRelatedFilesCache = new ModuleToRelatedFilesCache(project);

    final MyVirtualFileAdapter myFileListener = new MyVirtualFileAdapter();
    LocalFileSystem.getInstance().addVirtualFileListener(myFileListener);
    Disposer.register(project, new Disposable() {
      public void dispose() {
        LocalFileSystem.getInstance().removeVirtualFileListener(myFileListener);
      }
    });
    myReadErrStreamAlarm = new Alarm(Alarm.ThreadToUse.OWN_THREAD,project);
  }

  public ModuleToRelatedFilesCache getModuleToRelatedFilesCache() {
    return myModuleToRelatedFilesCache;
  }

  public BuiltInFlexCompilerHandler getBuiltInFlexCompilerHandler() {
    if (myBuiltInFlexCompilerHandler == null) {
      myBuiltInFlexCompilerHandler = new BuiltInFlexCompilerHandler(myProject);
    }
    return myBuiltInFlexCompilerHandler;
  }

  private ModuleOrFacetCompileCache getCache(FlexBuildConfiguration.Type type) {
    ModuleOrFacetCompileCache cache = myCompileCache.get(type);
    if (cache == null) {
      cache = new ModuleOrFacetCompileCache();
      myCompileCache.put(type, cache);
    }
    return cache;
  }

  @NotNull
  public String getComponentName() {
    return "FlexCompilerHandler";
  }

  public static FlexCompilerHandler getInstance(Project project) {
    return project.getComponent(FlexCompilerHandler.class);
  }

  public void projectOpened() {
    CompilerManager.getInstance(myProject).addBeforeTask(new FlexUnitPrecompileTask(myProject));
    CompilerManager.getInstance(myProject).addBeforeTask(new RunMainClassPrecompileTask(myProject));
  }

  public void projectClosed() {
    if (myBuiltInFlexCompilerHandler != null) {
      myBuiltInFlexCompilerHandler.stopCompilerProcess();
    }
    quitCompilerShell();
    myModuleToRelatedFilesCache.clear();
    deleteTempFlexConfigFiles(myProject.getName());
  }

  public void quitCompilerShell() {
    doQuit();
    clearFcshRelatedCache();
  }

  private void doQuit() {
    if (!processIsAlive()) return;
    myRequestedQuit = true;

    try {
      sendCommand("quit", new CompilerMessagesBuffer(null, false)); // ignoring input/output
    } catch (IOException ex) {
      // process exits
    }
  }

  private void clearFcshRelatedCache() {
    for (ModuleOrFacetCompileCache compileCache : myCompileCache.values()) {
      compileCache.moduleOrFacetToAutoGeneratedConfig.clear();
      compileCache.moduleOrFacetToCommand.clear();
      compileCache.configFileToTimestamp.clear();
    }

    commandToIdMap.clear();
  }

  enum Result {
    OK, TARGET_NOT_FOUND, NEED_TO_REPEAT_COMMAND, OUT_OF_MEMORY
  }

  private Process process;
  private OutputStream is;
  private InputStreamReader out;
  private LineNumberReader err;
  private final char[] buf = new char[8192];

  public void compileFlexModuleOrAllFlexFacets(final Module module, final CompileContext context) throws IOException {
    final FlexBuildConfiguration overriddenConfig = context.getUserData(OVERRIDE_BUILD_CONFIG);

    if (overriddenConfig != null && module == overriddenConfig.getModule()) {
      final Pair<Boolean, String> validationResultWithMessage =
        FlexCompiler.validateConfiguration(overriddenConfig, module, FlexBundle.message("module.name", module.getName()), false);
      if (!validationResultWithMessage.first) {
        if (validationResultWithMessage.second != null) {
          context.addMessage(CompilerMessageCategory.ERROR, validationResultWithMessage.second, null, -1, -1);
        }
        return;
      }
      compileModuleOrFacet(module, null, context, overriddenConfig, false);
    }
    else {
      final boolean nothingChangedSincePreviousCompilation = myModuleToRelatedFilesCache.isNothingChangedSincePreviousCompilation(module);

      if (module.getModuleType() instanceof FlexModuleType) {
        final Pair<Boolean, List<VirtualFile>> compilationResult =
          compileModuleOrFacet(module, null, context, FlexBuildConfiguration.getInstance(module), nothingChangedSincePreviousCompilation);
        if (compilationResult.first && !compilationResult.second.isEmpty()) {
          myModuleToRelatedFilesCache.cacheModuleWithDependencies(context, module, compilationResult.second);
        }
      }
      else {
        boolean wasFailure = false;
        Collection<List<VirtualFile>> allConfigFiles = new ArrayList<List<VirtualFile>>();

        for (final FlexFacet facet : FacetManager.getInstance(module).getFacetsByType(FlexFacet.ID)) {
          final Pair<Boolean, List<VirtualFile>> compilationResult =
            compileModuleOrFacet(module, facet, context, FlexBuildConfiguration.getInstance(facet), nothingChangedSincePreviousCompilation);
          if (!compilationResult.first) {
            wasFailure = true;
          }
          if (!compilationResult.second.isEmpty()) {
            allConfigFiles.add(compilationResult.second);
          }
        }

        if (!wasFailure && !allConfigFiles.isEmpty()) {
          myModuleToRelatedFilesCache.cacheModuleWithDependencies(context, module, allConfigFiles);
        }
      }
    }
  }

  static void deleteTempFlexUnitFiles(final CompileContext context) {
    if (!KEEP_TEMP_FILES) {
      final Collection<String> filesToDelete = context.getUserData(FlexUnitPrecompileTask.FILES_TO_DELETE);
      if (filesToDelete != null) {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            ApplicationManager.getApplication().runWriteAction(new Runnable() {
              public void run() {
                for (String path : filesToDelete) {
                  VirtualFile file = LocalFileSystem.getInstance().findFileByPath(path);
                  if (file != null && file.exists()) {
                    try {
                      file.delete(this);
                    }
                    catch (IOException e) {
                      LOG.warn("Failed to delete FlexUnit launcher file: " + path, e);
                    }
                  }
                }
              }
            });
          }
        });
      }
    }
  }

  static String generateConfigFileName(final Module module,
                                       final @Nullable FlexFacet flexFacet,
                                       final String prefix,
                                       final @Nullable String postfix) {
    final String hash1 = Integer.toHexString((SystemProperties.getUserName() + module.getProject().getName()).hashCode()).toUpperCase();
    final String hash2 = Integer.toHexString((module.getName() + (flexFacet == null ? "" : flexFacet.getName())).hashCode()).toUpperCase();
    return prefix + hash1 + "-" + hash2 + (postfix == null ? ".xml" : ("-" + postfix + ".xml"));
  }

  private static void deleteTempFlexConfigFiles(final String projectName) {
    if (!KEEP_TEMP_FILES) {
      final String hash1 = Integer.toHexString((SystemProperties.getUserName() + projectName).hashCode()).toUpperCase();
      final File dir = new File(FlexUtils.getTempFlexConfigsDirPath());

      if (dir.exists() && dir.isDirectory()) {
        final File[] filesToDelete = dir.listFiles(new FilenameFilter() {
          public boolean accept(final File dir, final String name) {
            if (name.endsWith(".xml")) {
              for (final FlexBuildConfiguration.Type type : FlexBuildConfiguration.Type.values()) {
                if (name.startsWith(type.getConfigFilePrefix() + hash1)) {
                  return true;
                }
              }
            }
            return false;
          }

        });

        if (filesToDelete != null) {
          for (final File file : filesToDelete) {
            FileUtil.delete(file);
          }
        }
      }
    }
  }

  /**
   * @return first is false if myModuleToRelatedFilesCache should not be cached;
   * second is a list of config files, may be empty if compilation skipped
   */
  private Pair<Boolean, List<VirtualFile>> compileModuleOrFacet(final Module module,
                                    @Nullable final FlexFacet flexFacet,
                                    final CompileContext context,
                                    @NotNull final FlexBuildConfiguration config,
                                    final boolean nothingChangedSincePreviousCompilation) throws IOException {
    if (context.getProgressIndicator().isCanceled()) {
      return Pair.create(false, Collections.<VirtualFile>emptyList());
    }

    if (!config.DO_BUILD) {
      return Pair.create(true, Collections.<VirtualFile>emptyList());
    }

    final String presentableName = FlexUtils.getPresentableName(module, flexFacet);
    if (context.isMake() && nothingChangedSincePreviousCompilation) {
      context
        .addMessage(CompilerMessageCategory.STATISTICS, FlexBundle.message("compilation.skipped.because.nothing.changed.in", presentableName),
                    null, -1, -1);
      return Pair.create(true, Collections.<VirtualFile>emptyList());
    }

    context.getProgressIndicator().setText(FlexBundle.message("compiling", presentableName));

    final Object moduleOrFacet = flexFacet == null ? module : flexFacet;
    final ModuleOrFacetCompileCache compileCache = getCache(config.getType());

    if (!context.isMake()) {
      dropIncrementalCompilation(moduleOrFacet, compileCache);
    }

    final Sdk flexSdk = FlexUtils.getFlexSdkForFlexModuleOrItsFlexFacets(module);
    assert flexSdk != null; // checked in FlexCompiler.validateConfiguration()

    final List<VirtualFile> configFiles = getConfigFiles(config, module, flexFacet);     // todo use FlexCompilationUtils.getConfigFiles()

    if (updateTimestamps(configFiles, compileCache, moduleOrFacet)) {
      // force non-incremental compilation because fcsh sometimes doesn't detect some changes in custom compiler config file
      dropIncrementalCompilation(moduleOrFacet, compileCache);
    }

    launchFcshIfNeeded(context, flexSdk);

    boolean compilationSuccessful = true;

    for (final String _cssFilePath : config.CSS_FILES_LIST) {
      final String cssFilePath = FileUtil.toSystemIndependentName(_cssFilePath);
      final FlexBuildConfiguration cssConfig = FlexCompilationUtils.createCssConfig(config, cssFilePath);
      final List<VirtualFile> cssConfigFiles = FlexCompilationUtils.getConfigFiles(cssConfig, module, flexFacet, cssFilePath);
      final String cssCommand = buildCommand(cssConfigFiles, cssConfig, flexSdk);

      FlexCompilationUtils.ensureOutputFileWritable(myProject, cssConfig.getOutputFileFullPath());
      compilationSuccessful &= sendCompilationCommand(context, flexSdk, cssCommand);

      // no need in incrementality for css files compilation, it's better to release a piece of fcsh heap
      final int commandIndex = commandToIdMap.get(cssCommand);
      if (commandIndex > 0) {
        sendCommand("clear " + commandIndex, new CompilerMessagesBuffer(null, false));
      }
    }

    final String command = buildCommand(configFiles, config, flexSdk);
    final String s = compileCache.moduleOrFacetToCommand.get(moduleOrFacet);
    final int previousCommandId = commandToIdMap.get(command);

    if (!config.USE_CUSTOM_CONFIG_FILE) {
      FlexCompilationUtils.ensureOutputFileWritable(myProject, config.getOutputFileFullPath());
    }

    if (s == null || !s.equals(command)) {
      if (s != null) {
        if (previousCommandId > 0) {
          sendCommand("clear " + previousCommandId, new CompilerMessagesBuffer(context, false));
          commandToIdMap.remove(command);
        }
      }

      compileCache.moduleOrFacetToCommand.put(moduleOrFacet, command);

      compilationSuccessful &= sendCompilationCommand(context, flexSdk, command);
    }
    else {
      compilationSuccessful &= sendCompilationCommand(context, flexSdk, previousCommandId > 0 ? "compile " + previousCommandId : null, command);
    }

    if (config.getType() == FlexBuildConfiguration.Type.Default) {
      if (!compilationSuccessful) {
        myModuleToRelatedFilesCache.markModuleAndDependentModulesDirty(module);
      }
    }

    if (!compilationSuccessful) {
      // force non-incremental compilation next time (bug in Flex incremental compiler: it doesn't recompile after failed compilation in some curcumstances)
      dropIncrementalCompilation(moduleOrFacet, compileCache);
    }

    return Pair.create(compilationSuccessful, configFiles);
  }

  private void dropIncrementalCompilation(final Object moduleOrFacet,
                                          final ModuleOrFacetCompileCache compileCache) throws IOException {
    final String removedCommand = compileCache.moduleOrFacetToCommand.remove(moduleOrFacet);
    final int commandId = commandToIdMap.remove(removedCommand);
    if (commandId > 0) {
      sendCommand("clear " + commandId, new CompilerMessagesBuffer(null, false));
    }
  }

  /**
   * @return true if some of timestamps exists and is out of date
   */
  private static boolean updateTimestamps(List<VirtualFile> configFiles, ModuleOrFacetCompileCache compileCache, Object moduleOrFacet) {
    boolean result = false;
    for (VirtualFile configFile : configFiles) {
      final long currentTimestamp = configFile.getModificationCount();

      final Long previousTimestamp = compileCache.configFileToTimestamp.get(configFile);
      if (previousTimestamp == null || !previousTimestamp.equals(currentTimestamp)) {
        if (previousTimestamp != null)  {
          result = true;
        }
        compileCache.configFileToTimestamp.put(configFile, currentTimestamp);
      }
    }
    return result;
  }

  private boolean sendCompilationCommand(final CompileContext context,
                                      final Sdk flexSdk,
                                      final String fullCommand) throws IOException {
    return sendCompilationCommand(context, flexSdk, null, fullCommand, true);
  }

  private boolean sendCompilationCommand(final CompileContext context,
                                      final Sdk flexSdk,
                                      @Nullable final String incrementalCommand,
                                      final String fullCommand) throws IOException {
    return sendCompilationCommand(context, flexSdk, incrementalCommand, fullCommand, true);
  }

  /**
   * @return true if compilation completes successfully
   */
  private boolean sendCompilationCommand(final CompileContext context,
                                      final Sdk flexSdk,
                                      @Nullable final String incrementalCommand,
                                      final String fullCommand,
                                      final boolean relaunchIfOutOfMemory) throws IOException {
    final CompilerMessagesBuffer messagesBuffer = new CompilerMessagesBuffer(context, true);
    Result result = sendCommand(incrementalCommand != null ? incrementalCommand : fullCommand, messagesBuffer);
    if (result != Result.OUT_OF_MEMORY && messagesBuffer.containsOutOfMemoryError()) {
      result = Result.OUT_OF_MEMORY;
    }

    switch (result) {
        case OK:
          messagesBuffer.flush();
          return !messagesBuffer.containsErrors();
        case TARGET_NOT_FOUND:
          messagesBuffer.flush();
          commandToIdMap.remove(fullCommand);
          return sendCompilationCommand(context, flexSdk, null, fullCommand, true);
        case NEED_TO_REPEAT_COMMAND:
          messagesBuffer.flush();
          consumeOutput(null, messagesBuffer);
          return sendCompilationCommand(context, flexSdk, null, fullCommand, true);
        case OUT_OF_MEMORY:
          quitCompilerShell();
          messagesBuffer.removeErrorsAndStackTrace();
          messagesBuffer.flush();
          addOutOfMemoryMessage(context, relaunchIfOutOfMemory);
          if (relaunchIfOutOfMemory) {
            launchFcshIfNeeded(context, flexSdk);
            return sendCompilationCommand(context, flexSdk, null, fullCommand, false);
          }
          else {
            return false;
          }
      }

    return false;
  }

  private static void addOutOfMemoryMessage(final CompileContext context, final boolean willBeRestarted) {
    if (willBeRestarted) {
      context.addMessage(CompilerMessageCategory.WARNING, FlexBundle.message("fcsh.out.of.memory.and.restarted"), null, -1, -1);
    }
    else {
      context.addMessage(CompilerMessageCategory.ERROR, FlexBundle.message("increase.flex.compiler.heap"), null, -1, -1);
    }
  }

  private void launchFcshIfNeeded(final CompileContext context, final Sdk flexSdk) throws IOException {
    if (!processIsAlive() || myRequestedQuit) {
      String classpath = FlexUtils.getPathToBundledJar("idea-fcsh-fix.jar");
      if (!(flexSdk.getSdkType() instanceof FlexmojosSdkType)) {
        classpath += File.pathSeparator + FileUtil.toSystemDependentName(flexSdk.getHomePath() + "/lib/fcsh.jar");
      }
      final List<String> cmdLineParams =
        FlexSdkUtils.getCommandLineForSdkTool(myProject, flexSdk, classpath, "com.intellij.flex.FcshLauncher", null);
      context.addMessage(CompilerMessageCategory.INFORMATION, StringUtil.join(cmdLineParams, " "), null, -1, -1);

      final ProcessBuilder builder = new ProcessBuilder(cmdLineParams);

      builder.directory(new File(FlexUtils.getFlexCompilerWorkDirPath(myProject, flexSdk)));

      process = builder.start();
      is = process.getOutputStream();
      out = new InputStreamReader(process.getInputStream());
      err = new LineNumberReader(new InputStreamReader(process.getErrorStream()));
      consumeOutput(null, new CompilerMessagesBuffer(context, false));

      clearFcshRelatedCache();
      myRequestedQuit = false;
    }
  }

  private boolean processIsAlive() {
    boolean processIsAlive = process != null;
    if (processIsAlive) {
      try {
        process.exitValue();
        processIsAlive = false;
      } catch (IllegalThreadStateException ignored) {}
    }
    return processIsAlive;
  }

  @NonNls
  @NotNull
  private String buildCommand(final List<VirtualFile> configFiles, final FlexBuildConfiguration config, final Sdk flexSdk) {  // todo change to FlexCompilationUtils.buildCommand()
    final StringBuilder configsParam = new StringBuilder();
    final String workDirPathWithSlash = FlexUtils.getFlexCompilerWorkDirPath(myProject, flexSdk) + "/";

    for (final VirtualFile configFile : configFiles) {
      String relativePathToConfig = configFile.getPath();
      if (configFile.getPath().startsWith(workDirPathWithSlash)) {
        relativePathToConfig = configFile.getPath().substring(workDirPathWithSlash.length());
      }
      if (relativePathToConfig.indexOf(' ') >= 0) {
        relativePathToConfig = "\"" + relativePathToConfig + "\"";
      }
      if (configsParam.length() > 0) {
        configsParam.append(",");
      }
      boolean useSdkConfig = config.USE_DEFAULT_SDK_CONFIG_FILE && !(flexSdk.getSdkType() instanceof FlexmojosSdkType);
      configsParam.append(" -load-config").append(useSdkConfig ? "+=" : "=").append(relativePathToConfig);
    }

    @NonNls String s = config.OUTPUT_TYPE.equals(FlexBuildConfiguration.APPLICATION) ? "mxmlc" : "compc";

    if (flexSdk.getSdkType() instanceof AirSdkType) {
      s += " +configname=air";
    }
    else if (flexSdk.getSdkType() instanceof AirMobileSdkType) {
      s += " +configname=airmobile";
    }

    s += configsParam;

    if(config.ADDITIONAL_COMPILER_OPTIONS != null && config.ADDITIONAL_COMPILER_OPTIONS.length() > 0) {
      s+= " " + FlexUtils.replacePathMacros(config.ADDITIONAL_COMPILER_OPTIONS, config.getModule());
    }

    return s;
  }

  private static void addLocales(final StringBuilder builder, final List<String> locales) {
    if (!locales.isEmpty()) {
      builder.append("\n    <locale>");
      for (final String locale : locales) {
        addTag(builder, "locale-element", locale, "\n      ");
      }
      builder.append("\n    </locale>");
    }
  }

  private static void addSourcePath(final Module module, final StringBuilder builder, final boolean isTest) {
    addSourcePath(module, builder, Collections.<String>emptyList(), isTest);
  }

  private static void addSourcePath(final Module module,
                                    final StringBuilder builder,
                                    final List<String> localesToSubstitute,
                                    final boolean isTest) {
    final Set<String> sourcePathsWithLocaleToken = new HashSet<String>(); // Set - to avoid duplication of paths like "locale/{locale}"
    final List<String> sourcePathsWithoutLocaleToken = new ArrayList<String>();

    for (VirtualFile sourceDir : ModuleRootManager.getInstance(module).getSourceRoots(isTest)) {
      if (localesToSubstitute.contains(sourceDir.getName())) {
        sourcePathsWithLocaleToken.add(sourceDir.getParent().getPath() + "/" + LOCALE_TOKEN);
      }
      else {
        sourcePathsWithoutLocaleToken.add(sourceDir.getPath());
      }
    }

    if (!sourcePathsWithLocaleToken.isEmpty() || !sourcePathsWithoutLocaleToken.isEmpty()) {
      builder.append("\n    <source-path append=\"true\">");
      // source paths with {locale} token should go first
      for (final String sourcePath : sourcePathsWithLocaleToken) {
        addTag(builder, "path-element", sourcePath, "\n      ");
      }
      for (final String sourcePath : sourcePathsWithoutLocaleToken) {
        addTag(builder, "path-element", sourcePath, "\n      ");
      }
      builder.append("\n    </source-path>");
    }
  }

  @NotNull
  private List<VirtualFile> getConfigFiles(FlexBuildConfiguration config, @NotNull final Module module, @Nullable final FlexFacet flexFacet)
    throws IOException {
    final Object moduleOrFacet = flexFacet == null ? module : flexFacet;

    List<VirtualFile> result = new ArrayList<VirtualFile>();
    if (config.USE_CUSTOM_CONFIG_FILE && !needToMergeAutogeneratedAndCustomConfigFile(config, false)) {
      final String customConfigFilePath =
        config.getType() == FlexBuildConfiguration.Type.FlexUnit && config.USE_CUSTOM_CONFIG_FILE_FOR_TESTS
        ? config.CUSTOM_CONFIG_FILE_FOR_TESTS
        : config.CUSTOM_CONFIG_FILE;
      final VirtualFile customConfigFile =
        VfsUtil.findRelativeFile(customConfigFilePath, FlexUtils.getFlexCompilerWorkDir(myProject, null));
      if (customConfigFile != null) {
        result.add(customConfigFile);
      }
    }

    if (!config.USE_CUSTOM_CONFIG_FILE ||
        config.getType() == FlexBuildConfiguration.Type.FlexUnit ||
        config.getType() == FlexBuildConfiguration.Type.OverriddenMainClass) {
      final ModuleOrFacetCompileCache compileCache = getCache(config.getType());
      VirtualFile generatedConfigFile = compileCache.moduleOrFacetToAutoGeneratedConfig.get(moduleOrFacet);
      final boolean regenerateTempConfig =
        generatedConfigFile != null && needToRegenerateMainClassBasedConfigFile(generatedConfigFile, config);
      if (regenerateTempConfig) {
        removeIncrementalCommandFor(generatedConfigFile);
      }
      if (generatedConfigFile == null || !generatedConfigFile.isValid() || regenerateTempConfig) {
        @NonNls final String name = generateConfigFileName(module, flexFacet, config.getType().getConfigFilePrefix(), null);

        final Ref<VirtualFile> fileRef = new Ref<VirtualFile>();
        final Ref<IOException> error = new Ref<IOException>();
        final String configText = generateConfigFileText(module, config, null);
        final Runnable runnable = new Runnable() {
          public void run() {
            fileRef.set(ApplicationManager.getApplication().runWriteAction(new NullableComputable<VirtualFile>() {
              public VirtualFile compute() {
                try {
                  final String baseDirPath = FlexUtils.getTempFlexConfigsDirPath();
                  final VirtualFile baseDir = VfsUtil.createDirectories(baseDirPath);

                  VirtualFile configFile = baseDir.findChild(name);
                  if (configFile == null) {
                    configFile = baseDir.createChildData(this, name);
                  }
                  mySavingConfigOurselves = true;
                  VfsUtil.saveText(configFile, configText);
                  return configFile;
                }
                catch (IOException ex) {
                  error.set(ex);
                }
                finally {
                  mySavingConfigOurselves = false;
                }
                return null;
              }
            }));
          }
        };

        if (ApplicationManager.getApplication().isUnitTestMode()) {
          runnable.run();
        }
        else {
          ApplicationManager.getApplication()
            .invokeAndWait(runnable, ProgressManager.getInstance().getProgressIndicator().getModalityState());
        }
        if (!error.isNull()) {
          throw error.get();
        }
        generatedConfigFile = fileRef.get();
        compileCache.moduleOrFacetToAutoGeneratedConfig.put(moduleOrFacet, generatedConfigFile);
        // no need to quit compiler shell if generated config file was rebuilt (it happens if user manually changes it or for class-based run configuration)
        compileCache.configFileToTimestamp.put(generatedConfigFile, generatedConfigFile.getModificationCount());
      }
      result.add(generatedConfigFile);
    }
    return result;
  }

  private void removeIncrementalCommandFor(final VirtualFile configFile) throws IOException {
    final Collection<String> commandsToRemove = new ArrayList<String>();
    commandToIdMap.forEachEntry(new TObjectIntProcedure<String>() {
      public boolean execute(final String command, int id) {
        if (command.contains(configFile.getName())) {
          commandsToRemove.add(command);
        }
        return true;
      }
    });
    for (final String command : commandsToRemove) {
      sendCommand("clear " + commandToIdMap.get(command), new CompilerMessagesBuffer(null, false));
      commandToIdMap.remove(command);
    }
  }

  private static boolean needToRegenerateMainClassBasedConfigFile(final VirtualFile configFile, final FlexBuildConfiguration config) {
    if (config.getType() != FlexBuildConfiguration.Type.OverriddenMainClass) return false;

    try {
      final String pathElement = FlexUtils.findXMLElement(configFile.getInputStream(), "<flex-config><file-specs><path-element>");
      return (pathElement == null || !pathElement.equals(FlexUtils.getPathToMainClassFile(config)));
    }
    catch (IOException e) {
      return true;
    }
  }

  static String generateConfigFileText(final Module module, final FlexBuildConfiguration config, final @Nullable String cssFilePath) {
    final boolean customConfigFileUsed = config.USE_CUSTOM_CONFIG_FILE;
    @NonNls final StringBuilder configTextBuilder = new StringBuilder();
    final ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(module.getProject()).getFileIndex();
    final Sdk sdk = FlexUtils.getFlexSdkForFlexModuleOrItsFlexFacets(module);

    configTextBuilder.append("<flex-config xmlns=\"http://www.adobe.com/2006/flex-config\">");

    if (cssFilePath != null) {
      final int lastSlashIndex = cssFilePath.lastIndexOf('/');
      final String cssDirPath = lastSlashIndex > 0 ? cssFilePath.substring(0, lastSlashIndex) : null;
      if (cssDirPath != null) {
        // folder that contains css file must be source folder and must be first in source-path list, otherwise stupid compiler says that css file must have package corresponding its path
        configTextBuilder
          .append("\n  <compiler>")
          .append("\n    <source-path append=\"true\">")
          .append("\n      <path-element>").append(cssDirPath).append("</path-element>")
          .append("\n    </source-path>")
          .append("\n  </compiler>");
      }
    }

    if (!customConfigFileUsed &&
        !StringUtil.isEmpty(config.TARGET_PLAYER_VERSION) &&
        sdk != null &&
        TargetPlayerUtils.isTargetPlayerApplicable(sdk)) {
      configTextBuilder.append("\n  <target-player>").append(config.TARGET_PLAYER_VERSION).append("</target-player>");
    }

    final boolean debug = FlexBuildConfiguration.APPLICATION.equals(config.OUTPUT_TYPE)
                          ? FlexCompilerProjectConfiguration.getInstance(module.getProject()).SWF_DEBUG_ENABLED
                          : FlexCompilerProjectConfiguration.getInstance(module.getProject()).SWC_DEBUG_ENABLED;

    configTextBuilder
      .append("\n  <compiler>")
      .append("\n    <debug>").append(String.valueOf(debug)).append("</debug>");

    final List<String> locales = new LinkedList<String>();

    if (!customConfigFileUsed && config.USE_LOCALE_SETTINGS) {
      for (final String locale : config.LOCALE.split(",")) {
        locales.add(locale.trim());
      }

      // in generated config file we put only locales set in respective field of Advanced tab and do not parse Additional compiler options here
      addLocales(configTextBuilder, locales);
    }

    // when adding source paths we respect locales set both in UI and in Additional compiler options
    locales.addAll(FlexUtils.getOptionValues(config.ADDITIONAL_COMPILER_OPTIONS, "locale", "compiler.locale"));
    addSourcePath(module, configTextBuilder, locales, config.getType() == FlexBuildConfiguration.Type.FlexUnit);

    handleModuleDependencies(module, configTextBuilder, config.getType() == FlexBuildConfiguration.Type.FlexUnit, cssFilePath != null);

    if (!customConfigFileUsed) {
      handleNamespacesAndManifestFiles(configTextBuilder, config.NAMESPACE_AND_MANIFEST_FILE_INFO_LIST);
      handleConditionalCompilationDefinitions(configTextBuilder, config.CONDITIONAL_COMPILATION_DEFINITION_LIST);
    }

    if (!customConfigFileUsed && !StringUtil.isEmpty(config.PATH_TO_SERVICES_CONFIG_XML)) {
      configTextBuilder.append("\n    <services>").append(config.PATH_TO_SERVICES_CONFIG_XML).append("</services>");
      configTextBuilder.append("\n    <context-root>").append(config.CONTEXT_ROOT).append("</context-root>");
    }

    configTextBuilder.append("\n  </compiler>");

    if (!customConfigFileUsed && !config.STATIC_LINK_RUNTIME_SHARED_LIBRARIES) {
      addTag(configTextBuilder, "static-link-runtime-shared-libraries", "false");
    }

    if (FlexBuildConfiguration.APPLICATION.equals(config.OUTPUT_TYPE)) {
      configTextBuilder.append("\n  <file-specs>");
      final String fileSpec = cssFilePath == null ? XmlUtil.escape(FlexUtils.getPathToMainClassFile(config)) : cssFilePath;
      addTag(configTextBuilder, "path-element", fileSpec, "\n    ");
      configTextBuilder.append("\n  </file-specs>");
    } else {
      if (!customConfigFileUsed) {
        handleIncludeNamespaces(configTextBuilder, config.NAMESPACE_AND_MANIFEST_FILE_INFO_LIST);
      }

      final ModuleFileIndex moduleFileIndex = ModuleRootManager.getInstance(module).getFileIndex();
      final CompilerConfiguration compilerConfig = CompilerConfiguration.getInstance(module.getProject());
      final List<String> classesToInclude = new ArrayList<String>();
      final List<Pair<String, String>> filesToInclude = new ArrayList<Pair<String, String>>();  // <name/> and <path/> for config file
      final boolean includeFilesInSwc =
        !customConfigFileUsed && FlexBuildConfiguration.LIBRARY.equals(config.OUTPUT_TYPE) && config.INCLUDE_RESOURCE_FILES_IN_SWC;
      final boolean isTest = config.getType() == FlexBuildConfiguration.Type.FlexUnit;

      ContentIterator ci = new ContentIterator() {
        public boolean processFile(final VirtualFile fileOrDir) {
          if (includeInCompilation(module.getProject(), fileOrDir)) {
            if (!isTest && projectFileIndex.isInTestSourceContent(fileOrDir)) {
              return true;
            }

            final VirtualFile rootForFile = projectFileIndex.getSourceRootForFile(fileOrDir);
            if (rootForFile != null) {
              final String packageText = VfsUtil.getRelativePath(fileOrDir.getParent(), rootForFile, '.');
              final String qName = (packageText.length() > 0 ? packageText + "." : "") + fileOrDir.getNameWithoutExtension();

              final boolean include = JavaScriptSupportLoader.isMxmlOrFxgFile(fileOrDir) ||
                                      ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {
                                        public Boolean compute() {
                                          // we include file in compilation if it has (or intended to have) some public declaration (class, namespace, function) which is equivalent to having JSPackageStatement declaration.
                                          // But first we try to find it in JSQualifiedElementIndex because it is faster.
                                          final Collection<JSQualifiedNamedElement> elements = StubIndex.getInstance()
                                            .get(JSQualifiedElementIndex.KEY, qName.hashCode(), module.getProject(),
                                                 GlobalSearchScope.moduleScope(module));
                                          if (elements.isEmpty()) {
                                            // If SomeClass.as contains IncorrectClass definition - we want to include this class into compilation so that compilation fails.
                                            final PsiFile psiFile = PsiManager.getInstance(module.getProject()).findFile(fileOrDir);
                                            return psiFile != null && PsiTreeUtil.getChildOfType(psiFile, JSPackageStatement.class) != null;
                                          }
                                          else {
                                            return true;
                                          }
                                        }
                                      });

              if (include) {
                classesToInclude.add(qName);
              }
            }
          } else if (includeFilesInSwc && isResourceFile(fileOrDir, compilerConfig)) {
            final VirtualFile rootForFile = projectFileIndex.getSourceRootForFile(fileOrDir);
            if (rootForFile != null) {
              final String packageText = VfsUtil.getRelativePath(fileOrDir.getParent(), rootForFile, '/');
              final String pathInSwc = (packageText.length() > 0 ? packageText + "/" : "") + fileOrDir.getName();
              filesToInclude.add(new Pair<String, String>(pathInSwc, fileOrDir.getPath()));
            }
          }
          return true;
        }
      };

      moduleFileIndex.iterateContent(ci);

      configTextBuilder.append("\n  <include-classes>");
      for (final String className : classesToInclude) {
        addTag(configTextBuilder, "class", XmlUtil.escape(className), "\n    ");
      }
      configTextBuilder.append("\n  </include-classes>");

      for (final Pair<String, String> fileInfo : filesToInclude) {
        configTextBuilder.append("\n  <include-file>");
        addTag(configTextBuilder, "name", XmlUtil.escape(fileInfo.first), "\n    ");
        addTag(configTextBuilder, "path", XmlUtil.escape(fileInfo.second), "\n    ");
        configTextBuilder.append("\n  </include-file>");
      }
    }

    final String outputFilePath = cssFilePath != null ? config.getOutputFileFullPath()
                                                      : config.getType() == FlexBuildConfiguration.Type.FlexUnit
                                                        ? config.getCompileOutputPathForTests() + "/" + config.OUTPUT_FILE_NAME
                                                        : config.getOutputFileFullPath();
    addTag(configTextBuilder, "output", outputFilePath);

    configTextBuilder.append("\n</flex-config>");

    final String configText = configTextBuilder.toString();
    return needToMergeAutogeneratedAndCustomConfigFile(config, cssFilePath != null)
           ? FlexCompilerConfigFileUtil.mergeWithCustomConfigFile(configText, config.CUSTOM_CONFIG_FILE, cssFilePath)
           : configText;
  }

  public static boolean needToMergeAutogeneratedAndCustomConfigFile(final FlexBuildConfiguration config, final boolean isCssCompilation) {
    return config.USE_CUSTOM_CONFIG_FILE
           && (isCssCompilation
               || (config.getType() == FlexBuildConfiguration.Type.FlexUnit && !config.USE_CUSTOM_CONFIG_FILE_FOR_TESTS)
               || (config.getType() == FlexBuildConfiguration.Type.OverriddenMainClass));
  }

  private static boolean includeInCompilation(final Project project, final VirtualFile file) {
    if (CompilerManager.getInstance(project).isExcludedFromCompilation(file)){
      return false;
    }

    return file.getFileType() == ActionScriptFileType.INSTANCE ||
           JavaScriptSupportLoader.isMxmlOrFxgFile(file);
  }

  private static boolean isResourceFile(final VirtualFile file, final CompilerConfiguration compilerConfig) {
    return file != null &&
           !file.isDirectory() &&
           !StdFileTypes.JAVA.equals(file.getFileType()) &&
           compilerConfig.isResourceFile(file) &&
           !compilerConfig.isExcludedFromCompilation(file);
  }

  private static void handleModuleDependencies(final Module module,
                                               final StringBuilder configTextBuilder,
                                               final boolean isTest,
                                               final boolean neverIncludeLibs) {
    final List<String> libraryPaths = new ArrayList<String>();
    final List<String> externalLibraryPaths = new ArrayList<String>();
    final List<String> includedLibraryPaths = new ArrayList<String>();
    final List<String> rawLibSourcePaths = new ArrayList<String>();

    for (final OrderEntry o : ModuleRootManager.getInstance(module).getOrderEntries()) {

      final DependencyScope scope = o instanceof ExportableOrderEntry ? ((ExportableOrderEntry)o).getScope() : DependencyScope.COMPILE;
      final boolean export = neverIncludeLibs ? false
                                              : (o instanceof ExportableOrderEntry ? ((ExportableOrderEntry)o).isExported() : false);

      if (scope == DependencyScope.RUNTIME || (scope == DependencyScope.TEST && !isTest)) {
        continue;
      }

      if (o instanceof LibraryOrderEntry) {
        final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)o;
        if (AutogeneratedLibraryUtils.isAutogeneratedLibrary(libraryOrderEntry)) {
          continue;
        }

        for (VirtualFile libFile : libraryOrderEntry.getRootFiles(OrderRootType.CLASSES)) {
          libFile = getRealFile(libFile);

          if (libFile != null && libFile.isDirectory()) {
            rawLibSourcePaths.add(libFile.getPath());
          }
          else if (libFile != null && !libFile.isDirectory() && "swc".equalsIgnoreCase(libFile.getExtension())) {
            // "airglobal.swc" and "playerglobal.swc" file names are hardcoded in Flex compiler
            // including libraries like "playerglobal-3.5.0.12683-9.swc" may lead to error at runtime like "VerifyError Error #1079: Native methods are not allowed in loaded code."
            // so here we just skip including such libraries in config file.
            // Compilation should be ok because base flexmojos config file contains correct reference to its copy in target/classes/libraries/playerglobal.swc
            final String libFileName = libFile.getName();
            if (libFileName.startsWith("airglobal")) {
              if (libFileName.equals("airglobal.swc")) {
                externalLibraryPaths.add(libFile.getPath());
              }
            }
            else if (libFileName.startsWith("playerglobal")) {
              if (libFileName.equals("playerglobal.swc")) {
                externalLibraryPaths.add(libFile.getPath());
              }
            }
            else {
              if (scope == DependencyScope.PROVIDED) {
                externalLibraryPaths.add(libFile.getPath());
              }
              else if (export) {
                includedLibraryPaths.add(libFile.getPath());
              }
              else {
                libraryPaths.add(libFile.getPath());
              }
            }
          }
        }
      }
      else if (o instanceof ModuleOrderEntry) {
        final Module moduleDependency = ((ModuleOrderEntry)o).getModule();

        if (moduleDependency != null) {
          for (final FlexBuildConfiguration configOfDependency : FlexBuildConfiguration
            .getConfigForFlexModuleOrItsFlexFacets(moduleDependency)) {
            // TODO: module dependency logic should also somehow depend on DO_BUILD, USE_CUSTOM_CONFIG_FILE
            if (FlexBuildConfiguration.LIBRARY.equals(configOfDependency.OUTPUT_TYPE)) {
              if (scope == DependencyScope.PROVIDED) {
                externalLibraryPaths.add(configOfDependency.getOutputFileFullPath());
              }
              else if (export) {
                includedLibraryPaths.add(configOfDependency.getOutputFileFullPath());
              }
              else {
                libraryPaths.add(configOfDependency.getOutputFileFullPath());
              }
            }
            else {
              // TODO is it a good (historical) solution to add source folders of other module to compilation?
              addSourcePath(moduleDependency, configTextBuilder, isTest);
            }
          }
        }
      }
    }

    addPathElements(configTextBuilder, "source-path", "path-element", rawLibSourcePaths);
    addPathElements(configTextBuilder, "external-library-path", "path-element", externalLibraryPaths);
    addPathElements(configTextBuilder, "library-path", "path-element", libraryPaths);
    addPathElements(configTextBuilder, "include-libraries", "library", includedLibraryPaths);
  }

  private static void addPathElements(final StringBuilder configTextBuilder, final String enclosingElementName, final String pathElementName, final List<String> paths) {
    if (!paths.isEmpty()) {
      configTextBuilder.append("\n    <").append(enclosingElementName).append(" append=\"true\">");
      for (final String path : paths) {
        addTag(configTextBuilder, pathElementName, path, "\n      ");
      }
      configTextBuilder.append("\n    </").append(enclosingElementName).append(">");
    }
  }

  private static void handleNamespacesAndManifestFiles(final StringBuilder configTextBuilder,
                                final List<FlexBuildConfiguration.NamespaceAndManifestFileInfo> namespaceAndManifestFileInfoList) {
    if (!namespaceAndManifestFileInfoList.isEmpty()) {
      configTextBuilder.append("\n    <namespaces>");
      for (final FlexBuildConfiguration.NamespaceAndManifestFileInfo info : namespaceAndManifestFileInfoList) {
        configTextBuilder.append("\n      <namespace append=\"true\">");
        addTag(configTextBuilder, "uri", XmlUtil.escape(info.NAMESPACE), "\n        ");
        addTag(configTextBuilder, "manifest", XmlUtil.escape(info.MANIFEST_FILE_PATH), "\n        ");
        configTextBuilder.append("\n      </namespace>");
      }
      configTextBuilder.append("\n    </namespaces>");
    }
  }

  private static void handleConditionalCompilationDefinitions(final StringBuilder configTextBuilder,
                                final List<FlexBuildConfiguration.ConditionalCompilationDefinition> conditionalCompilationDefinitionList) {
      for (final FlexBuildConfiguration.ConditionalCompilationDefinition definition : conditionalCompilationDefinitionList) {
        configTextBuilder.append("\n    <define append=\"true\">");
        addTag(configTextBuilder, "name", definition.NAME, "\n      ");
        addTag(configTextBuilder, "value", definition.VALUE, "\n      ");
        configTextBuilder.append("\n    </define>");
    }
  }

  private static void handleIncludeNamespaces(final StringBuilder configTextBuilder,
                                       final List<FlexBuildConfiguration.NamespaceAndManifestFileInfo> namespaceAndManifestFileInfoList) {
    if (!namespaceAndManifestFileInfoList.isEmpty()) {
      configTextBuilder.append("\n  <include-namespaces>");
      for (final FlexBuildConfiguration.NamespaceAndManifestFileInfo info : namespaceAndManifestFileInfoList) {
        if (info.INCLUDE_IN_SWC) {
          addTag(configTextBuilder, "uri", info.NAMESPACE, "\n    ");
        }
      }
      configTextBuilder.append("\n  </include-namespaces>");
    }
  }

  private static void addTag(final StringBuilder configTextBuilder, @NonNls final String tagName, @NonNls final String tagValue) {
    addTag(configTextBuilder, tagName, tagValue, "\n  ");
  }

  private static void addTag(final StringBuilder configTextBuilder, @NonNls final String tagName, @NonNls final String tagValue, @NonNls String delimiter) {
    configTextBuilder.append(delimiter).append("<").append(tagName).append(">").append(tagValue).append("</").append(tagName).append(">");
  }

  @Nullable
  private static VirtualFile getRealFile(final VirtualFile libFile) {
    if (libFile.getFileSystem() instanceof JarFileSystem) {
      return JarFileSystem.getInstance().getVirtualFileForJar(libFile);
    }
    return libFile;
  }

  static final Pattern errorPattern = Pattern.compile("(.*?)(\\(\\D.*\\))?(?:\\((-?\\d+)\\))?: ?(?:col: (-?\\d+))? (Warning|Error): (.*)");

  private Result sendCommand(@NonNls final String command, final CompilerMessagesBuffer messagesBuffer) throws IOException {
    trace(TraceType.IN, command);
    messagesBuffer.addMessage(CompilerMessageCategory.INFORMATION, command, null, -1, -1);
    if (processIsAlive()) {
      is.write((command + "\n").getBytes());
      is.flush();

      final Runnable runnable = new Runnable() {
        public void run() {
          if (myCancelledReadErrStream) return;
          scanErrorStream(messagesBuffer);

          myReadErrStreamAlarm.addRequest(this, 100);
        }

      };

      if ("quit".equals(command)) return Result.OK;
      myCancelledReadErrStream = false;
      myReadErrStreamAlarm.addRequest(runnable, 100);
    }
    return consumeOutput(command, messagesBuffer);
  }

  private volatile boolean myCancelledReadErrStream;
  private final Alarm myReadErrStreamAlarm;

  private void scanErrorStream(final CompilerMessagesBuffer messagesBuffer) {
    try {
      int available;
      while ((available = process.getErrorStream().available()) > 2 || err.ready()) { // 2 is \r\n, prevent lock of read line to appear
        @NonNls final String errLine = err.readLine();
        trace(TraceType.ERR, errLine);
        if (errLine == null || errLine.length() == 0) continue;

        ApplicationManager.getApplication().runReadAction(new Runnable() {
          public void run() {
            dispatchError(errLine, messagesBuffer);
          }
        });
      }
    }
    catch (IOException ex) {
      LOG.error(ex);
    }
  }

  private static void dispatchError(final String errLine, final CompilerMessagesBuffer messagesBuffer) {
    final Matcher matcher = errorPattern.matcher(errLine);

    if (matcher.matches()) {
      final String file = matcher.group(1);
      final String additionalInfo = matcher.group(2);
      final String line = matcher.group(3);
      final String column = matcher.group(4);
      final String type = matcher.group(5);
      final String message = matcher.group(6);

      final CompilerMessageCategory messageCategory =
          "Warning".equals(type) ? CompilerMessageCategory.WARNING : CompilerMessageCategory.ERROR;
      final VirtualFile relativeFile = VfsUtil.findRelativeFile(file, null);
      final String fullMessage = additionalInfo == null ? message : additionalInfo + " " + message;
      messagesBuffer.addMessage(messageCategory, fullMessage, relativeFile != null ? relativeFile.getUrl() : null,
                                line != null ? Integer.parseInt(line) : 0, column != null ? Integer.parseInt(column) : 0);
    }
    else if (isErrorMessage(errLine)) {
      final String errorPrefix = "Error: ";
      final String errorText = errLine.startsWith(errorPrefix) ? errLine.substring(errorPrefix.length()) : errLine;
      messagesBuffer.addMessage(CompilerMessageCategory.ERROR, errorText, null, -1, -1);
    }
    else {
      messagesBuffer.addMessage(CompilerMessageCategory.INFORMATION, errLine, null, -1, -1);
    }
  }

  private static boolean isErrorMessage(final String errLine) {
    return errLine.startsWith("Error: ") || errLine.startsWith("Exception in thread \"main\" ");
  }

  private Result consumeOutput(final String command, @Nullable final CompilerMessagesBuffer messagesBuffer) throws IOException {
    Result result = Result.OK;
    String lastRead = "";

    out:
    while(true) {
      int read = out.read(buf);
      if (read == -1) {
        read = err.read(buf);
        if (read > 0) {
          messagesBuffer.addMessage(CompilerMessageCategory.ERROR, new String(buf, 0, read), null, -1, -1);
        }
        break;
      }


      @NonNls String output = lastRead + new String(buf, 0, read);
      trace(TraceType.OUT, output);
      StringTokenizer tokenizer = new StringTokenizer(output, "\r\n");

      while(tokenizer.hasMoreElements()) {
        @NonNls String s = tokenizer.nextElement().trim();
        if (s.length() == 0) continue;

        if (s.startsWith("(fcsh)")) {
          if (s.indexOf("need to repeat command") != -1) { // special marker from idea-fcsh-fix;
            // if fcsh-idea-fix fails for any reason it launches standard fcsh, so we need to repeat command
            result = Result.NEED_TO_REPEAT_COMMAND;
          } else if (s.indexOf("out of memory") != -1) {
            result = Result.OUT_OF_MEMORY;
          }
          myCancelledReadErrStream = true;
          myReadErrStreamAlarm.cancelAllRequests();
          scanErrorStream(messagesBuffer);
          break out;
        }
        if (s.startsWith(FCSH_ASSIGNED_MARKER) && command != null) {
          int id = Integer.parseInt(s.substring(FCSH_ASSIGNED_MARKER.length(), s.indexOf(' ', FCSH_ASSIGNED_MARKER.length())));
          commandToIdMap.put(command, id);
          continue;
        } else if(s.startsWith("fcsh: Target") && s.indexOf("not found") != -1) {
          result = Result.TARGET_NOT_FOUND;
          continue;
        }

        if (!tokenizer.hasMoreElements() && tokenizer.getCurrentPosition() == output.length()) {
          lastRead = s + "\n";
          break;
        }
        messagesBuffer.addMessage(CompilerMessageCategory.INFORMATION, s, null, -1, -1);
      }
    }

    return result;
  }

  enum TraceType {
    IN, OUT, ERR
  }

  private static void trace(TraceType type, String message) {
    System.out.println(type.toString() + ":" + message);
  }

  private class MyVirtualFileAdapter extends VirtualFileAdapter {
    @Override
      public void propertyChanged(final VirtualFilePropertyEvent event) {
      handleVirtualFileEvent(event.getFile());
    }

    @Override
      public void contentsChanged(final VirtualFileEvent event) {
      handleVirtualFileEvent(event.getFile(), true);
    }

    @Override
      public void fileCreated(final VirtualFileEvent event) {
      handleVirtualFileEvent(event.getFile());
    }

    @Override
      public void fileDeleted(final VirtualFileEvent event) {
      handleVirtualFileEvent(event.getFile());
    }

    @Override
      public void fileMoved(final VirtualFileMoveEvent event) {
      handleVirtualFileEvent(event.getFile());
    }

    @Override
      public void fileCopied(final VirtualFileCopyEvent event) {
      handleVirtualFileEvent(event.getFile());
    }

    private void handleVirtualFileEvent(final VirtualFile file) {
      handleVirtualFileEvent(file, false);
    }

    private void handleVirtualFileEvent(final VirtualFile file, boolean contentsChanged) {
      if (file == null) return;
      myModuleToRelatedFilesCache.markDependentModulesDirty(file);
      clearAutoGeneratedConfigsIfNeeded(file, contentsChanged);
    }

    private void clearAutoGeneratedConfigsIfNeeded(final VirtualFile file, final boolean contentsChanged) {
      boolean allEmpty = true;
      for (ModuleOrFacetCompileCache cache : myCompileCache.values()) {
        if (!cache.moduleOrFacetToAutoGeneratedConfig.isEmpty()) {
          allEmpty = false;
          break;
        }
      }

      if (allEmpty) return;

      if (contentsChanged && file.getFileType() == StdFileTypes.XML && !JavaScriptSupportLoader.isMxmlOrFxgFile(file)) {
        if (mySavingConfigOurselves) return;

        // External change, need to regenerate file if it's one of the config files
        for (ModuleOrFacetCompileCache cache : myCompileCache.values()) {
          final List<Object> moduleOrFacetList = cache.moduleOrFacetToAutoGeneratedConfig.getKeysByValue(file);
          if (moduleOrFacetList != null && !moduleOrFacetList.isEmpty()) {
            cache.moduleOrFacetToAutoGeneratedConfig.remove(moduleOrFacetList.get(0));
            return;
          }
        }
      }
      else if (!contentsChanged && (includeInCompilation(myProject, file) || isResourceFile(file, CompilerConfiguration.getInstance(myProject)))) {
        final VirtualFile contentRootForFile = ProjectRootManager.getInstance(myProject).getFileIndex().getContentRootForFile(file);
        if (contentRootForFile != null) {
          for (ModuleOrFacetCompileCache cache : myCompileCache.values()) {
            cache.moduleOrFacetToAutoGeneratedConfig.clear();
          }
        }
      }
    }
  }
}
