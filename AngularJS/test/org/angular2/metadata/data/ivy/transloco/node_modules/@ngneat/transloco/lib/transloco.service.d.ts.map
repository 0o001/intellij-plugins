{"version":3,"file":"transloco.service.d.ts","sources":["/Users/piotr.tomiak/WebstormProjects/ng9rc/node_modules/@ngneat/transloco/lib/transloco.service.d.ts"],"sourcesContent":["import { OnDestroy } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { TranslocoLoader } from './transloco.loader';\nimport { TranslocoTranspiler } from './transloco.transpiler';\nimport { AvailableLangs, HashMap, InlineLoader, LoadOptions, SetTranslationOptions, TranslateParams, Translation, TranslocoEvents } from './types';\nimport { TranslocoConfig } from './transloco.config';\nimport { TranslocoMissingHandler } from './transloco-missing-handler';\nimport { TranslocoInterceptor } from './transloco.interceptor';\nimport { TranslocoFallbackStrategy } from './transloco-fallback-strategy';\nexport declare function translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\nexport declare class TranslocoService implements OnDestroy {\n    private loader;\n    private parser;\n    private missingHandler;\n    private interceptor;\n    private userConfig;\n    private fallbackStrategy;\n    private subscription;\n    private translations;\n    private cache;\n    private firstFallbackLang;\n    private defaultLang;\n    private mergedConfig;\n    private availableLangs;\n    private isResolvedMissingOnce;\n    private lang;\n    langChanges$: Observable<string>;\n    private events;\n    events$: Observable<TranslocoEvents>;\n    private failedCounter;\n    private failedLangs;\n    constructor(loader: TranslocoLoader, parser: TranslocoTranspiler, missingHandler: TranslocoMissingHandler, interceptor: TranslocoInterceptor, userConfig: TranslocoConfig, fallbackStrategy: TranslocoFallbackStrategy);\n    readonly config: TranslocoConfig;\n    getDefaultLang(): string;\n    setDefaultLang(lang: string): void;\n    getActiveLang(): string;\n    setActiveLang(lang: string): this;\n    setAvailableLangs(langs: AvailableLangs): void;\n    getAvailableLangs(): AvailableLangs;\n    load(path: string, options?: LoadOptions): Observable<Translation>;\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     *\n     */\n    selectTranslate<T = any>(key: TranslateParams, params?: HashMap, lang?: string, _isObject?: boolean): Observable<T>;\n    /**\n     * Translate the given path that returns an object\n     *\n     * @example\n     *\n     * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\n     *\n     */\n    translateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\n    selectTranslateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): Observable<T>;\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * getTranslation()\n     * getTranslation('en')\n     * getTranslation('admin-page/en')\n     */\n    getTranslation(): Map<string, Translation>;\n    getTranslation(lang: string): Translation;\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe()\n     * selectTranslation('es').subscribe()\n     */\n    selectTranslation(lang?: string): Observable<Translation>;\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation: Translation, lang?: string, options?: SetTranslationOptions): void;\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     */\n    setTranslationKey(key: string, value: string, lang?: string): void;\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang }: TranslocoConfig): void;\n    /**\n     * @internal\n     */\n    _handleMissingKey(key: string, value: any, params?: HashMap): any;\n    /**\n     * @internal\n     */\n    _isLangScoped(lang: string): boolean;\n    /**\n     * @internal\n     */\n    _isLang(lang: string): boolean;\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path: string, inlineLoader?: InlineLoader): Observable<Translation | Translation[]>;\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope: string): string;\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope: string, alias: string): void;\n    ngOnDestroy(): void;\n    private isLoadedTranslation;\n    private getAvailableLangsIds;\n    private useFallbackTranslation;\n    private handleSuccess;\n    private handleFailure;\n    private getMappedScope;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgJA;"}