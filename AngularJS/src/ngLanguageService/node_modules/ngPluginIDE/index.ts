import {Completion, Diagnostic, LanguageServiceHost} from "../../typings/types";
import * as ts from "../../typings/tsserverlibrary";
import {CompletionInfo} from "../../typings/tsserverlibrary";
import * as utilObj from '../../typings/util';

function init(modules: { typescript: typeof ts }) {
    const projectHostMap = new WeakMap<ts.server.Project, LanguageServiceHost>();

    let ng = modules.typescript["ng_service"];
    if (ng == null || modules.typescript["skipNg"]) return;
    let util: typeof utilObj = modules.typescript["ideUtil"];
    let versionNumbers = util.parseNumbersInVersion(modules.typescript.version);
    let is240OrMore = util.isVersionMoreOrEqual(versionNumbers, 2, 4, 0);
    if (!is240OrMore) return;

    function create(info: ts.server.PluginCreateInfo) {
        let project = info.project;

        const serviceHost = new ng.TypeScriptServiceHost(info.languageServiceHost, info.languageService);
        const ls = ng.createLanguageService(serviceHost as any);
        serviceHost.setSite(ls);
        projectHostMap.set(info.project, serviceHost);


        const proxy: ts.LanguageService = Object.create(null);
        let oldLS: ts.LanguageService = info.languageService;
        for (const k in oldLS) {
            (<any>proxy)[k] = function () {
                return (<any>oldLS)[k].apply(oldLS, arguments);
            }
        }

        (<any>proxy).getSuggestionDiagnostics = function (fileName: string) {
            let isHtml = isHtmlFile(fileName);
            return isHtml ? [] : (<any>oldLS).getSuggestionDiagnostics(fileName);
        }
        
        proxy.getSyntacticDiagnostics = function (fileName: string) {
            let isHtml = isHtmlFile(fileName);
            return isHtml ? [] : oldLS.getSyntacticDiagnostics(fileName);
        }

        proxy.getSemanticDiagnostics = function (fileName: string) {
            let isHtml = isHtmlFile(fileName);
            let result = isHtml ? [] : oldLS.getSemanticDiagnostics(fileName);
            let base = result || [];
            tryOperation('get diagnostics', () => {
                if (isHtml) {
                    let isIncluded = isIncludeToExternalFiles(fileName);
                    if (!isIncluded) return;
                }

                info.project.projectService.logger.info(`Computing Angular semantic diagnostics...`);
                const ours = ls.getDiagnostics(fileName);
                if (ours && ours.length) {
                    const file = oldLS.getProgram().getSourceFile(fileName);
                    base = base.concat(ours.map(d => diagnosticToDiagnostic(d, file)));
                    info.project.projectService.logger.info(`End computing semantic diagnostics... ${ours.length} `);
                } else {
                    info.project.projectService.logger.info(`No diagnostics, used based ${base.length} `);
                }
            });

            return base;
        };


        let isIncludeToExternalFiles = function (fileName: string) {
            if (info.project.projectKind == modules.typescript.server.ProjectKind.Inferred) {
                return false;
            }

            let externalFiles: string[] = getExternalFiles(info.project);
            let isIncluded = false;
            for (let file of externalFiles) {
                if (file == fileName) {
                    isIncluded = true;
                }
            }
            return isIncluded;
        };
        proxy.getCompletionsAtPosition = function (fileName: string, position: number) {
            let isHtml = isHtmlFile(fileName);
            let result = isHtml ? null : oldLS.getCompletionsAtPosition(fileName, position);
            let base: CompletionInfo = result || {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: []
            };
            tryOperation('get completions', () => {
                if (isHtml) {
                    let isIncluded = isIncludeToExternalFiles(fileName);
                    if (!isIncluded) return base;
                }

                const results = ls.getCompletionsAt(fileName, position);
                if (results && results.length) {
                    if (base === undefined) {
                        base = {
                            isGlobalCompletion: false,
                            isMemberCompletion: false,
                            isNewIdentifierLocation: false,
                            entries: []
                        };
                    }
                    for (const entry of results) {
                        base.entries.push(completionToEntry(entry));
                    }
                }
            });
            return base;
        }

        function tryOperation<T>(attempting: string, callback: () => T): T | null {
            try {
                return callback();
            } catch (e) {
                info.project.projectService.logger.info(`Failed to ${attempting}: ${e.toString()}`);
                info.project.projectService.logger.info(`Stack trace: ${e.stack}`);
                return null;
            }
        }

        function isHtmlFile(fileName: string) {
            return fileName.toLowerCase().endsWith(".html");
        }

        return proxy;
    }

    function getExternalFiles(project: any): string[] | undefined {
        const host = projectHostMap.get(project);
        if (host && project.program) {
            return host.getTemplateReferences();
        }
    }

    function completionToEntry(c: Completion): ts.CompletionEntry {
        return {kind: c.kind, name: c.name, sortText: c.sort, kindModifiers: ''};
    }

    function diagnosticToDiagnostic(d: Diagnostic, file: ts.SourceFile): ts.Diagnostic {
        const result = {
            file,
            start: d.span.start,
            length: d.span.end - d.span.start,
            messageText: d.message,
            category: modules.typescript.DiagnosticCategory.Error,
            code: 0,
            source: 'ng'
        };
        return result;
    }


    return {create, getExternalFiles};
}


export = init;
