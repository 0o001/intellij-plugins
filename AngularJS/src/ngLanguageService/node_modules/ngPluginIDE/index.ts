import {Completion, Diagnostic, LanguageServiceHost} from "../../typings/types";
import * as ts from "../../typings/tsserverlibrary";
import {CompletionInfo} from "../../typings/tsserverlibrary";

declare let console;

function init(modules: { typescript: typeof ts }) {
    const projectHostMap = new WeakMap<ts.server.Project, LanguageServiceHost>();


    let ng = modules.typescript["ng_service"];
    if (ng == null) return;

    function create(info: ts.server.PluginCreateInfo) {


        console.log("Service created for " + info.project.getProjectName());
        const serviceHost = new ng.TypeScriptServiceHost(info.languageServiceHost, info.languageService);
        const ls = ng.createLanguageService(serviceHost as any);
        serviceHost.setSite(ls);
        projectHostMap.set(info.project, serviceHost);


        const proxy: ts.LanguageService = Object.create(null);
        let oldLS: ts.LanguageService = info.languageService;
        for (const k in oldLS) {
            (<any>proxy)[k] = function () {
                return (<any>oldLS)[k].apply(oldLS, arguments);
            }
        }
        proxy.getSemanticDiagnostics = function (fileName: string) {
            let isHtml = fileName.toLowerCase().endsWith(".html");
            let result = isHtml ? [] : oldLS.getSemanticDiagnostics(fileName);
            const base = result || [];
            tryOperation('get diagnostics', () => {
                if (isHtml) {
                    let isIncluded = isIncludeToExternalFiles(fileName);
                    if (!isIncluded) return;
                }
                
                info.project.projectService.logger.info(`Computing Angular semantic diagnostics...`);
                const ours = ls.getDiagnostics(fileName);
                if (ours && ours.length) {
                    const file = oldLS.getProgram().getSourceFile(fileName);
                    base.push.apply(base, ours.map(d => diagnosticToDiagnostic(d, file)));
                }
            });

            return base;
        };


        let isIncludeToExternalFiles = function (fileName: string) {
            let externalFiles: string[] = getExternalFiles(info.project);
            let isIncluded = false;
            for (let file of externalFiles) {
                if (file == fileName) {
                    isIncluded = true;
                }
            }
            return isIncluded;
        };
        proxy.getCompletionsAtPosition = function (fileName: string, position: number) {
            let isHtml = fileName.toLowerCase().endsWith(".html");
            let result = isHtml ? null : oldLS.getCompletionsAtPosition(fileName, position);
            let base: CompletionInfo = result || {
                isGlobalCompletion: false,
                isMemberCompletion: false,
                isNewIdentifierLocation: false,
                entries: []
            };
            tryOperation('get completions', () => {
                if (isHtml) {
                    let isIncluded = isIncludeToExternalFiles(fileName);
                    if (!isIncluded) return base;
                }

                const results = ls.getCompletionsAt(fileName, position);
                if (results && results.length) {
                    if (base === undefined) {
                        base = {
                            isGlobalCompletion: false,
                            isMemberCompletion: false,
                            isNewIdentifierLocation: false,
                            entries: []
                        };
                    }
                    for (const entry of results) {
                        base.entries.push(completionToEntry(entry));
                    }
                }
            });
            return base;
        }

        function tryOperation<T>(attempting: string, callback: () => T): T | null {
            try {
                return callback();
            } catch (e) {
                info.project.projectService.logger.info(`Failed to ${attempting}: ${e.toString()}`);
                info.project.projectService.logger.info(`Stack trace: ${e.stack}`);
                return null;
            }
        }

        return proxy;
    }

    function getExternalFiles(project: any): string[] | undefined {
        const host = projectHostMap.get(project);
        if (host) {
            console.log("Return host for" + project.getProjectName());
            return host.getTemplateReferences();
        } else {
            console.log("Cannot file host for " + project.getProjectName());
        }
    }

    function completionToEntry(c: Completion): ts.CompletionEntry {
        return {kind: c.kind, name: c.name, sortText: c.sort, kindModifiers: ''};
    }

    function diagnosticToDiagnostic(d: Diagnostic, file: ts.SourceFile): ts.Diagnostic {
        const result = {
            file,
            start: d.span.start,
            length: d.span.end - d.span.start,
            messageText: d.message,
            category: modules.typescript.DiagnosticCategory.Error,
            code: 0,
            source: 'ng'
        };
        return result;
    }


    return {create, getExternalFiles};
}


export = init;
