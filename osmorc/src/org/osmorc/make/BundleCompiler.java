/*
 * Copyright (c) 2007-2009, Osmorc Development Team
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright notice, this list
 *       of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, this
 *       list of conditions and the following disclaimer in the documentation and/or other
 *       materials provided with the distribution.
 *     * Neither the name of 'Osmorc Development Team' nor the names of its contributors may be
 *       used to endorse or promote products derived from this software without specific
 *       prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.osmorc.make;

import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.compiler.*;
import com.intellij.openapi.module.Module;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.roots.*;
import com.intellij.openapi.util.Computable;
import com.intellij.openapi.util.Condition;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.io.FileUtil;
import com.intellij.openapi.vfs.VfsUtilCore;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.util.ArrayUtil;
import com.intellij.util.containers.ContainerUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.osmorc.facet.OsmorcFacet;
import org.osmorc.facet.OsmorcFacetConfiguration;
import org.osmorc.facet.maven.LocalPackageCollector;
import org.osmorc.frameworkintegration.CachingBundleInfoProvider;
import org.osmorc.frameworkintegration.FrameworkInstanceLibraryManager;

import java.io.DataInput;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * This is a compiler step that builds up a bundle. Depending on user settings the compiler either uses a user-edited
 * manifest or builds up a manifest using bnd.
 *
 * @author <a href="mailto:janthomae@janthomae.de">Jan Thom&auml;</a>
 */
public class BundleCompiler implements PackagingCompiler {
  /**
   * Condition which matches order entries that are not representing a framework library.
   */
  public static final Condition<OrderEntry> NOT_FRAMEWORK_LIBRARY_CONDITION = new Condition<OrderEntry>() {
    @Override
    public boolean value(OrderEntry entry) {
      return !(entry instanceof LibraryOrderEntry) ||
             !FrameworkInstanceLibraryManager.isFrameworkInstanceLibrary((LibraryOrderEntry)entry);
    }
  };

  @Override
  public void processOutdatedItem(CompileContext compileContext, String s, @Nullable final ValidityState validityState) {
    // used to delete the generated jar files here, however this could lead to jar files being accidentally deleted
    // when running a run configuration that did not include the artifacts generated by this compiler (see IDEA-76731).
    // so the jar file is now deleted right before it is rebuilt in {@link #buildBundle}. The AndroidPackagingCompiler
    // and J2MEPackagingCompiler classes seem to handle it in a similar fashion.
  }

  /**
   * Returns all processing items (modules with bundles to be created) for the given compile context.
   */
  @NotNull
  @Override
  public ProcessingItem[] getProcessingItems(final CompileContext compileContext) {
    return ApplicationManager.getApplication().runReadAction(new Computable<ProcessingItem[]>() {
      public ProcessingItem[] compute() {
        // find and add all dependent modules to the list of stuff to be compiled
        Module[] affectedModules = compileContext.getCompileScope().getAffectedModules();
        if (affectedModules.length == 0) {
          return ProcessingItem.EMPTY_ARRAY;
        }

        List<ProcessingItem> result = ContainerUtil.newArrayList();
        for (Module module : affectedModules) {
          OsmorcFacet facet = OsmorcFacet.getInstance(module);
          if (facet != null) {
            result.add(new BundleProcessingItem(module, facet));
          }
        }
        return result.toArray(new ProcessingItem[result.size()]);
      }
    });
  }

  /**
   * Processes a processing item (module).
   */
  @Override
  public ProcessingItem[] process(CompileContext compileContext, ProcessingItem[] processingItems) {
    for (ProcessingItem processingItem : processingItems) {
      BundleProcessingItem bundleProcessingItem = (BundleProcessingItem)processingItem;
      buildBundle(bundleProcessingItem.getModule(), bundleProcessingItem.getFacet(), compileContext);
    }
    return processingItems;
  }

  /**
   * Builds the bundle for a given module.
   */
  private static void buildBundle(Module module, OsmorcFacet facet, CompileContext context) {
    ProgressIndicator progressIndicator = context.getProgressIndicator();
    progressIndicator.setText("Building bundle for module " + module.getName());

    String messagePrefix = "[" + module.getName() + "] ";

    // create the jar file
    File jarFile = new File(VfsUtilCore.urlToPath(getJarFileName(module)));
    FileUtil.delete(jarFile);
    if (!FileUtil.createParentDirs(jarFile)) {
      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + "Cannot create path to " + jarFile.getPath(), null, 0, 0);
      return;
    }

    OsmorcFacetConfiguration configuration = facet.getConfiguration();

    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);
    if (moduleOutputUrl == null) {
      String message = "Unable to determine the compiler output path for module " + module.getName();
      context.addMessage(CompilerMessageCategory.WARNING, message, null, 0, 0);
      return;
    }
    File moduleOutputDir = VfsUtilCore.virtualToIoFile(moduleOutputUrl);

    List<String> classPathUrls = ContainerUtil.newSmartList(moduleOutputUrl.getUrl());

    // build a bnd file or use a provided one.
    File bndFile = getBndFile(module, facet, context, moduleOutputDir);
    if (bndFile == null) {
      // error already reported
      return;
    }

    String outputPath = jarFile.getPath();
    if (configuration.isUseBundlorFile()) {
      // we create a temp jar file in this case.
      outputPath += ".tmp.jar";
    }

    progressIndicator.setText2("Running bnd to build the bundle");
    try {
      BndWrapper.build(module, context, bndFile, classPathUrls, outputPath);
    }
    catch (Exception e) {
      context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + "Unexpected error: " + e.getMessage(), null, 0, 0);
      return;
    }

    // if we use bundlor, let bundlor work on the generated file.
    if (configuration.isUseBundlorFile()) {
      progressIndicator.setText2("Running bundlor to calculate the manifest");

      File bundlorFile = findFileInModuleContentRoots(configuration.getBundlorFileLocation(), module);
      if (bundlorFile == null || !bundlorFile.exists()) {
        String message = String.format("The Bundlor file \"%s\" for module \"%s\" does not exist.",
                                       configuration.getBundlorFileLocation(), module.getName());
        context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, configuration.getBundlorFileLocation(), 0, 0);
        return;
      }

      BundlorWrapper bw = new BundlorWrapper();
      try {
        if (!bw.wrapModule(context, outputPath, jarFile.getPath(), bundlorFile.getPath())) {
          String message = "Bundlifying the file " + jarFile.getPath() + " with Bundlor failed.";
          context.addMessage(CompilerMessageCategory.ERROR, messagePrefix + message, null, 0, 0);
          return;
        }
      }
      finally {
        // delete the tmp jar
        File tempJar = new File(outputPath);
        if (tempJar.exists() && !tempJar.delete()) {
          String message = "Could not delete temporary file: " + tempJar.getPath();
          context.addMessage(CompilerMessageCategory.WARNING, messagePrefix + message, null, 0, 0);
        }
      }
    }

    if (!configuration.isUseBndFile() && !configuration.isUseBundlorFile()) {
      // finally bundlify all the libs for this one
      bundlifyLibraries(module, progressIndicator, context);
    }
  }

  @Nullable
  private static File getBndFile(Module module, OsmorcFacet facet, CompileContext context, File moduleOutputDir) {
    String prefix = "[" + module.getName() + "] ";
    OsmorcFacetConfiguration configuration = facet.getConfiguration();

    if (configuration.isUseBndFile()) {
      String fileLocation = configuration.getBndFileLocation();
      File bndFile = findFileInModuleContentRoots(fileLocation, module);
      if (bndFile != null && bndFile.canRead()) {
        return bndFile;
      }
      else {
        String message = String.format("The bnd file \"%s\" for module \"%s\" does not exist.", fileLocation, module.getName());
        context.addMessage(CompilerMessageCategory.ERROR, prefix + message, fileLocation, 0, 0);
        return null;
      }
    }

    // use a linked hash map to keep the order of properties.
    Map<String, String> buildProperties = new LinkedHashMap<String, String>();
    if (configuration.isManifestManuallyEdited() || configuration.isOsmorcControlsManifest()) {
      if (configuration.isOsmorcControlsManifest()) {
        // fully osmorc controlled, no bnd file, read in all  properties
        buildProperties.putAll(configuration.getBndFileProperties());
      }
      else if (configuration.isManifestManuallyEdited()) { // manually edited manifest
        boolean manifestExists = false;
        VirtualFile manifestFile = facet.getManifestFile();
        if (manifestFile != null) {
          String manifestFilePath = manifestFile.getPath();
          if (manifestFilePath != null) {
            buildProperties.put("-manifest", manifestFilePath);
            manifestExists = true;
          }
        }
        if (!manifestExists) {
          String message = "Manifest file for module " + module.getName() + ": '" + facet.getManifestLocation() +
                           "' does not exist or cannot be found. Check that file exists and is not excluded from the module.";
          context.addMessage(CompilerMessageCategory.ERROR, prefix + message, null, 0, 0);
          return null;
        }
      }

      StringBuilder pathBuilder = new StringBuilder();

      // add all the class paths to include resources, so stuff from the project gets copied over.
      // XXX: one could argue if this should be done for a non-osmorc build
      pathBuilder.append(moduleOutputDir.getPath());

      // now include the paths from the configuration
      List<Pair<String, String>> list = configuration.getAdditionalJARContents();
      for (Pair<String, String> stringStringPair : list) {
        if (pathBuilder.length() > 0) pathBuilder.append(",");
        pathBuilder.append(stringStringPair.second).append(" = ").append(stringStringPair.first);
      }

      // and tell bnd what resources to include
      String includedResources = configuration.getAdditionalPropertiesAsMap().get("Include-Resource");
      if (includedResources == null) {
        includedResources = pathBuilder.toString();
      }
      else {
        includedResources = includedResources + "," + pathBuilder.toString();
      }
      buildProperties.put("Include-Resource", includedResources);

      // add the ignore pattern for the resources
      if (!configuration.getIgnoreFilePattern().isEmpty()) {
        if (!configuration.isIgnorePatternValid()) {
          String message = "The file ignore pattern in the facet configuration is invalid.";
          context.addMessage(CompilerMessageCategory.ERROR, prefix + message, null, 0, 0);
          return null;
        }
        buildProperties.put("-donotcopy", configuration.getIgnoreFilePattern());
      }

      if (configuration.isOsmorcControlsManifest()) {
        // support the {local-packages} instruction
        context.getProgressIndicator().setText2("Calculating local packages");
        LocalPackageCollector.addLocalPackages(moduleOutputDir, buildProperties);
      }
    }
    else if (!configuration.isUseBundlorFile()) {
      String message = "OSGi facet configuration for module " + module.getName() + " seems to be invalid. " +
                       "No supported manifest handling method is set up. Please check configuration and try again.";
      context.addMessage(CompilerMessageCategory.ERROR, prefix + message, null, 0, 0);
      return null;
    }

    File outputDir = BndWrapper.getOutputDir(moduleOutputDir, context);
    if (outputDir == null) {
      // error already reported
      return null;
    }
    try {
      return BndWrapper.makeBndFile(module, buildProperties, outputDir);
    }
    catch (IOException e) {
      String message = "Problem when generating bnd file: " + e.getMessage();
      context.addMessage(CompilerMessageCategory.ERROR, prefix + message, null, 0, 0);
      return null;
    }
  }

  @Nullable
  protected static File findFileInModuleContentRoots(String file, Module module) {
    ModuleRootManager manager = ModuleRootManager.getInstance(module);
    for (VirtualFile root : manager.getContentRoots()) {
      VirtualFile result = VfsUtilCore.findRelativeFile(file, root);
      if (result != null) {
        return new File(result.getPath());
      }
    }
    return null;
  }

  /**
   * Returns the manifest file for the given module if it exists
   *
   * @param module the module
   * @return the manifest file or null if it doesnt exist
   */
  @Nullable
  public static VirtualFile getManifestFile(@NotNull Module module) {
    OsmorcFacet facet = OsmorcFacet.getInstance(module);
    // FIXES Exception (http://ea.jetbrains.com/browser/ea_problems/17161)
    if (facet == null) {
      return null;
    }
    ModuleRootManager manager = ModuleRootManager.getInstance(module);
    for (VirtualFile root : manager.getContentRoots()) {
      VirtualFile result = VfsUtilCore.findRelativeFile(facet.getManifestLocation(), root);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  @NotNull
  @Override
  public String getDescription() {
    return "bundle compile";
  }

  @Override
  public boolean validateConfiguration(CompileScope compileScope) {
    return true;
  }

  /**
   * Recreates a validity state from a data input stream.
   */
  @Override
  public ValidityState createValidityState(DataInput in) throws IOException {
    return new BundleValidityState(in);
  }


  /**
   * Returns a virtual file representing the module's output path.
   */
  @Nullable
  public static VirtualFile getModuleOutputUrl(@NotNull Module module) {
    CompilerModuleExtension extension = CompilerModuleExtension.getInstance(module);
    return extension != null ? extension.getCompilerOutputPath() : null;
  }

  /**
   * Bundlifies all libraries that belong to the given module and that are not bundles and that are not modules.
   * The bundles are cached, so if * the source library does not change, it will not be bundlified again.
   * Returns a string array containing the urls of the bundlified libraries.
   */
  @NotNull
  public static String[] bundlifyLibraries(@NotNull Module module,
                                           @NotNull ProgressIndicator indicator,
                                           @NotNull CompileContext compileContext) {
    File outputDir = null;
    VirtualFile moduleOutputUrl = getModuleOutputUrl(module);
    if (moduleOutputUrl != null) {
      outputDir = BndWrapper.getOutputDir(VfsUtilCore.virtualToIoFile(moduleOutputUrl), compileContext);
    }
    if (outputDir == null) {
      // couldn't create output path, abort here..
      return ArrayUtil.EMPTY_STRING_ARRAY;
    }

    String[] urls = OrderEnumerator.orderEntries(module)
      .withoutSdk()
      .withoutModuleSourceEntries()
      .withoutDepModules()
      .productionOnly()
      .runtimeOnly()
      .recursively()
      .exportedOnly()
      .satisfying(NOT_FRAMEWORK_LIBRARY_CONDITION)
      .classes().getUrls();
    List<String> result = new ArrayList<String>();
    BndWrapper wrapper = new BndWrapper();
    for (String url : urls) {
      url = convertJarUrlToFileUrl(url);
      if (CachingBundleInfoProvider.canBeBundlified(url)) { // Fixes IDEA-56666
        indicator.setText("Bundling non-OSGi libraries for module: " + module.getName());
        indicator.setText2(url);
        // ok it is not a bundle, so we need to bundlify
        String bundledLocation = wrapper.wrapLibrary(module, compileContext, url, outputDir);
        // if no bundle could (or should) be created, we exempt this library
        if (bundledLocation != null) {
          result.add(fixFileURL(bundledLocation));
        }
      }
      else if (CachingBundleInfoProvider.isBundle(url)) { // Exclude non-bundles (IDEA-56666)
        result.add(fixFileURL(url));
      }
    }
    return ArrayUtil.toStringArray(result);
  }

  /**
   * Converts a jar url gained from OrderEntry.getUrls or Library.getUrls into a file url that can be processed.
   */
  @NotNull
  public static String convertJarUrlToFileUrl(@NotNull String url) {
    // urls end with !/ we cut that
    // XXX: not sure if this is a hack
    url = url.replaceAll("!.*", "");
    url = url.replace("jar://", "file://");
    return url;
  }

  /**
   * On Windows a file url must have at least 3 slashes at the beginning. 2 for the protocol separation and one for
   * the empty host (e.g.: file:///c:/bla instead of file://c:/bla). If there are only two the drive letter is
   * interpreted as the host of the url which naturally doesn't exist. On Unix systems it's the same case, but since
   * all paths start with a slash, a misinterpretation of part of the path as a host cannot occur.
   */
  @NotNull
  public static String fixFileURL(@NotNull String url) {
    return url.startsWith("file:///") ? url : url.replace("file://", "file:///");
  }

  /**
   * Builds the name of the jar file for a given module.
   */
  @Nullable
  public static String getJarFileName(@NotNull final Module module) {
    final OsmorcFacet facet = OsmorcFacet.getInstance(module);
    if (facet != null) {
      return facet.getConfiguration().getJarFileLocation();
    }
    return null;
  }
}
